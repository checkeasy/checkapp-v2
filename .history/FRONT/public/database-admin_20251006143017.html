<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ†Ô∏è CheckEasy - Admin Database (Int√©gr√©)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 20px 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 1.8em;
            margin-bottom: 10px;
        }
        
        .tabs {
            display: flex;
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            flex-wrap: wrap;
        }
        
        .tab {
            flex: 1;
            min-width: 120px;
            padding: 12px 15px;
            border: none;
            background: transparent;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            color: #6c757d;
            font-size: 0.9em;
        }
        
        .tab.active {
            background: white;
            color: #495057;
            border-bottom: 3px solid #007bff;
        }
        
        .tab:hover {
            background: #e9ecef;
        }
        
        .content {
            padding: 20px;
            min-height: 600px;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
        }
        
        .section h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        
        .btn {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin: 3px;
            transition: all 0.3s;
            font-weight: 600;
            font-size: 0.9em;
        }
        
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0,123,255,0.3);
        }
        
        .btn.danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }
        
        .btn.success {
            background: linear-gradient(135deg, #28a745 0%, #1e7e34 100%);
        }
        
        .btn.warning {
            background: linear-gradient(135deg, #ffc107 0%, #e0a800 100%);
            color: black;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            font-size: 0.9em;
        }
        
        .data-table th {
            background: #343a40;
            color: white;
            padding: 10px;
            text-align: left;
            font-weight: 600;
        }
        
        .data-table td {
            padding: 10px;
            border-bottom: 1px solid #dee2e6;
            word-break: break-word;
        }
        
        .data-table tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        .data-table tr:hover {
            background: #e9ecef;
        }
        
        .json-viewer {
            background: #2d3748;
            color: #e2e8f0;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
            margin: 10px 0;
            line-height: 1.4;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
            border-left: 4px solid #007bff;
        }
        
        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #007bff;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: #6c757d;
            font-weight: 600;
            font-size: 0.9em;
        }
        
        .search-box {
            width: 100%;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .search-box:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.25);
        }
        
        .alert {
            padding: 12px;
            margin: 12px 0;
            border-radius: 5px;
            font-weight: 600;
            font-size: 0.9em;
        }
        
        .alert.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .alert.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .alert.info {
            background: #cce7ff;
            color: #004085;
            border: 1px solid #b3d7ff;
        }
        
        .loading {
            display: inline-block;
            width: 18px;
            height: 18px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #007bff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .toolbar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .key-value-grid {
            display: grid;
            gap: 8px;
        }
        
        .key-value {
            display: grid;
            grid-template-columns: 1fr 2fr 80px;
            gap: 10px;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #dee2e6;
            font-size: 0.85em;
        }
        
        .key {
            font-weight: 600;
            color: #495057;
            word-break: break-word;
        }
        
        .value {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
            background: #f8f9fa;
            padding: 4px 6px;
            border-radius: 3px;
            word-break: break-all;
            max-height: 60px;
            overflow-y: auto;
        }
        
        .actions {
            display: flex;
            gap: 3px;
        }
        
        .btn-small {
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 3px;
            min-width: 25px;
        }
        
        .parcours-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            border-left: 4px solid #28a745;
        }
        
        .parcours-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .parcours-title {
            font-weight: 600;
            color: #495057;
            font-size: 1.1em;
        }
        
        .parcours-meta {
            font-size: 0.8em;
            color: #6c757d;
            margin: 5px 0;
        }
        
        .progress-bar {
            background: #e9ecef;
            border-radius: 10px;
            height: 8px;
            margin: 8px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            background: linear-gradient(90deg, #28a745, #20c997);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }
        
        @media (max-width: 768px) {
            .container {
                margin: 5px;
                border-radius: 10px;
            }
            
            .content {
                padding: 15px;
            }
            
            .key-value {
                grid-template-columns: 1fr;
                gap: 5px;
            }
            
            .tabs {
                flex-direction: column;
            }
            
            .tab {
                flex: none;
            }
        }
        
        .db-error {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            color: #856404;
        }
        
        /* JSON Viewer am√©lior√© */
        .json-enhanced {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            font-family: 'Monaco', 'Consolas', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            max-height: 600px;
            overflow-y: auto;
            border: 1px solid #3c3c3c;
        }
        
        .json-key {
            color: #9cdcfe;
            font-weight: 600;
        }
        
        .json-string {
            color: #ce9178;
        }
        
        .json-number {
            color: #b5cea8;
        }
        
        .json-boolean {
            color: #569cd6;
        }
        
        .json-null {
            color: #808080;
        }
        
        .json-object {
            border-left: 2px solid #404040;
            padding-left: 12px;
            margin-left: 8px;
        }
        
        .json-array {
            border-left: 2px solid #404040;
            padding-left: 12px;
            margin-left: 8px;
        }
        
        .json-toggle {
            cursor: pointer;
            user-select: none;
            color: #808080;
            margin-right: 5px;
            display: inline-block;
            width: 12px;
        }
        
        .json-toggle:hover {
            color: #ffffff;
        }
        
        .json-collapsed {
            display: none;
        }
        
        .data-section {
            background: white;
            border-radius: 8px;
            margin: 15px 0;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .data-section-header {
            background: #f8f9fa;
            padding: 12px 20px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        
        .data-section-header:hover {
            background: #e9ecef;
        }
        
        .data-section-title {
            font-weight: 600;
            color: #495057;
        }
        
        .data-section-badge {
            background: #007bff;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .data-section-content {
            padding: 20px;
        }
        
        .checkid-selector {
            background: white;
            border: 2px solid #007bff;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .checkid-selector select {
            width: 100%;
            padding: 10px;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            font-size: 16px;
        }
        
        .data-overview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }
        
        .overview-item {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            border-left: 3px solid #007bff;
        }
        
        .overview-label {
            font-size: 0.8em;
            color: #6c757d;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .overview-value {
            font-size: 1.1em;
            font-weight: 600;
            color: #495057;
        }
        
        /* Styles Webhook */
        .webhook-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #28a745;
        }
        
        .webhook-endpoint {
            background: #e9ecef;
            padding: 8px 12px;
            border-radius: 5px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9em;
            margin: 5px 0;
            word-break: break-all;
        }
        
        .webhook-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 5px;
            font-weight: 600;
            margin: 5px 0;
        }
        
        .webhook-status.success {
            background: #d4edda;
            color: #155724;
        }
        
        .webhook-status.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .webhook-status.pending {
            background: #fff3cd;
            color: #856404;
        }
        
        .log-entry {
            padding: 10px;
            margin: 8px 0;
            border-radius: 5px;
            border-left: 3px solid #007bff;
            background: #f8f9fa;
            font-size: 0.9em;
        }
        
        .log-entry.success {
            border-left-color: #28a745;
            background: #d4edda;
        }
        
        .log-entry.error {
            border-left-color: #dc3545;
            background: #f8d7da;
        }
        
        .log-timestamp {
            font-size: 0.8em;
            color: #6c757d;
            font-weight: 600;
        }
        
        .json-preview {
            max-height: 300px;
            overflow-y: auto;
        }
        
        .badge {
            display: inline-block;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: 600;
            border-radius: 10px;
        }
        
        .badge.success {
            background: #28a745;
            color: white;
        }
        
        .badge.secondary {
            background: #6c757d;
            color: white;
        }
        
        /* Styles Configuration Webhook */
        .webhook-config-controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
            margin: 15px 0;
        }
        
        .config-group {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .config-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: #495057;
            cursor: pointer;
        }
        
        .config-text {
            font-size: 14px;
        }
        
        .config-group select {
            padding: 5px 10px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background: white;
            font-size: 14px;
        }
        
        .config-preview {
            margin: 20px 0;
            padding: 15px;
            background: white;
            border-radius: 5px;
            border: 1px solid #dee2e6;
        }
        
        .config-preview-label {
            font-size: 12px;
            color: #6c757d;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .config-preview-url {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            color: #007bff;
            word-break: break-all;
            background: #f8f9fa;
            padding: 8px;
            border-radius: 3px;
        }
        
        .config-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõ†Ô∏è CheckEasy - Database Browser</h1>
            <p>üîç Consultation des donn√©es locales et parcours</p>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('checkid')">üÜî CheckID Browser</button>
            <button class="tab" onclick="showTab('parcours')">üèÉ Parcours</button>
            <button class="tab" onclick="showTab('localStorage')">üíæ Storage</button>
            <button class="tab" onclick="showTab('indexedDB')">üóÑÔ∏è IndexedDB</button>
            <button class="tab" onclick="showTab('photos')">üì∏ Photos</button>
            <button class="tab" onclick="showTab('webhooks')">üöÄ Historique Webhooks</button>
            <button class="tab" onclick="showTab('tools')">üîß Outils</button>
        </div>
        
        <div class="content">
            <!-- CheckID Browser -->
            <div id="checkid" class="tab-content active">
                <div class="toolbar">
                    <select id="checkIdSelect" onchange="loadCheckIdData()">
                        <option value="">S√©lectionner un CheckID</option>
                    </select>
                    <button class="btn" onclick="refreshCheckIds()">üîÑ Actualiser</button>
                </div>
                
                <div id="selectedCheckIdInfo" class="section" style="display: none;">
                    <h3 id="checkIdTitle">CheckID: </h3>
                    <div id="checkIdStats" class="stats-grid"></div>
                </div>
                
                <div id="checkIdDataContent"></div>
                
                <!-- Section Configuration Webhook -->
                <div id="webhookConfigSection" style="display: none;" class="section">
                    <h3>‚öôÔ∏è Configuration Endpoint</h3>
                    
                    <div class="webhook-config-controls">
                        <div class="config-group">
                            <label class="config-label">
                                <input type="checkbox" id="initializeCheckbox" checked onchange="updateEndpointConfig()">
                                <span class="config-text">Inclure "/initialize" dans l'endpoint</span>
                            </label>
                        </div>
                        
                        <div class="config-group">
                            <label class="config-label">
                                <span class="config-text">Environnement:</span>
                                <select id="environmentSelect" onchange="updateEndpointConfig()">
                                    <option value="test">üß™ Version Test</option>
                                    <option value="live">üöÄ Version Live</option>
                                </select>
                            </label>
                        </div>
                        
                        <div class="config-preview">
                            <div class="config-preview-label">URL compl√®te:</div>
                            <div class="config-preview-url" id="fullEndpointPreview">https://checkeasy-57905.bubbleapps.io/version-test/api/1.1/wf/checkinendpoint/initialize</div>
                        </div>
                        
                        <div class="config-actions">
                            <button class="btn" onclick="testEndpointConfig()">üîß Tester Configuration</button>
                            <button class="btn" onclick="resetEndpointConfig()">üîÑ Reset</button>
                        </div>
                    </div>
                </div>
                
                <!-- Section Webhook Sender -->
                <div id="webhookSection" style="display: none;" class="section">
                    <h3>üöÄ Envoi vers Bubble API</h3>
                    
                    <div class="data-overview">
                        <div class="overview-item">
                            <div class="overview-label">Endpoints configur√©s</div>
                            <div class="overview-value" id="currentEndpointDisplay">checkinendpoint/initialize</div>
                        </div>
                        <div class="overview-item">
                            <div class="overview-label">CheckID s√©lectionn√©</div>
                            <div class="overview-value" id="selectedCheckIdDisplay">-</div>
                        </div>
                        <div class="overview-item">
                            <div class="overview-label">ID Webhook (g√©n√©r√©)</div>
                            <div class="overview-value" id="generatedWebhookIdDisplay">-</div>
                        </div>
                        <div class="overview-item">
                            <div class="overview-label">√âtat session</div>
                            <div class="overview-value" id="sessionStateDisplay">-</div>
                        </div>
                        <div class="overview-item">
                            <div class="overview-label">Raison d√©tection</div>
                            <div class="overview-value" id="sessionStateReason">-</div>
                        </div>
                    </div>
                    
                    <div class="webhook-controls">
                        <button class="btn" onclick="debugSessionState()">üîç Test √âtat Session</button>
                        <button class="btn" onclick="testNewDataStructure()">üè† Test Structure CheckIn</button>
                        <button class="btn" onclick="testCheckoutStructure()">üßπ Test Structure CheckOut</button>
                        <button class="btn" onclick="debugPhotoExtraction()">üì∏ Debug Photos</button>
                        <button class="btn" onclick="debugUserExtraction()">üë§ Debug Utilisateur</button>
                        <button class="btn" onclick="debugParcoursLogement()">üè† Debug Parcours/Logement</button>
                        <button class="btn" onclick="debugEtapesDetails()">üéØ Debug √âtapes</button>
                        <button class="btn" onclick="testEtapeIdCleaning()">üßπ Test Nettoyage EtapeId</button>
                        <button class="btn" onclick="fetchParcoursData()">üîç R√©cup√©rer Donn√©es Parcours</button>
                        <button class="btn" onclick="testEtapeIdGeneration()">üîÑ Test G√©n√©ration EtapeId</button>
                        <button class="btn" onclick="loadParcoursDataFromApi()">üì° Charger Donn√©es API</button>
                        <button class="btn" onclick="testEtapeIdMapping()">üó∫Ô∏è Test Mapping EtapeId</button>
                        <button class="btn" onclick="verifyEtapeSourceData()">üî¨ V√©rifier Source √âtapes</button>
                        <button class="btn" onclick="previewStructureEtapes()">üèóÔ∏è Preview Structure √âtapes</button>
                        <button class="btn" onclick="generateCheckinData()">üì• G√©n√©rer CheckIn</button>
                        <button class="btn" onclick="generateCheckoutData()">üì§ G√©n√©rer CheckOut</button>
                        <button class="btn" onclick="generateUnifiedData()">üéØ G√©n√©rer Webhook Unifi√©</button>
                        <button class="btn success large" onclick="sendUnifiedWebhook()" id="sendUnifiedBtn" style="font-size: 16px; padding: 12px 24px; font-weight: bold;">üéØ ENVOYER WEBHOOK COMPLET (CHECKIN + CHECKOUT)</button>
                        <hr style="margin: 20px 0; border: 1px solid #ddd;">
                        <p style="color: #666; font-size: 12px; margin-bottom: 10px;">‚ö†Ô∏è Anciens webhooks s√©par√©s (d√©pr√©ci√©) :</p>
                        <button class="btn success" onclick="sendWebhook('checkin')" id="sendCheckinBtn">üöÄ Envoyer CheckIn</button>
                        <button class="btn success" onclick="sendWebhook('checkout')" id="sendCheckoutBtn">üöÄ Envoyer CheckOut</button>
                    </div>
                    
                    <div id="debugSection" style="display: none;" class="data-section">
                        <div class="data-section-header" onclick="toggleSection('debug-content')">
                            <div class="data-section-title">üîç Debug - Analyse des photos</div>
                            <div class="data-section-badge">Technique</div>
                        </div>
                        <div class="data-section-content" id="debug-content">
                            <div id="debugContent">Cliquez sur "Debug Photos" pour analyser</div>
                        </div>
                    </div>
                    
                    <div class="data-section">
                        <div class="data-section-header" onclick="toggleSection('checkin-preview')">
                            <div class="data-section-title">üì• Donn√©es CheckIn g√©n√©r√©es</div>
                            <div class="data-section-badge">JSON</div>
                        </div>
                        <div class="data-section-content" id="checkin-preview">
                            <div id="checkinDataPreview" class="json-enhanced">Cliquez sur "G√©n√©rer donn√©es CheckIn"</div>
                        </div>
                    </div>
                    
                    <div class="data-section">
                        <div class="data-section-header" onclick="toggleSection('checkout-preview')">
                            <div class="data-section-title">üì§ Donn√©es CheckOut g√©n√©r√©es</div>
                            <div class="data-section-badge">JSON</div>
                        </div>
                        <div class="data-section-content" id="checkout-preview">
                            <div id="checkoutDataPreview" class="json-enhanced">Cliquez sur "G√©n√©rer donn√©es CheckOut"</div>
                        </div>
                    </div>

                    <div class="data-section">
                        <div class="data-section-header" onclick="toggleSection('unified-preview')">
                            <div class="data-section-title">üéØ Donn√©es Webhook UNIFI√â (CHECKIN + CHECKOUT)</div>
                            <div class="data-section-badge">JSON Complet</div>
                        </div>
                        <div class="data-section-content" id="unified-preview">
                            <div id="unifiedDataPreview" class="json-enhanced">Cliquez sur "G√©n√©rer Webhook Unifi√©"</div>
                        </div>
                    </div>

                    <div class="data-section">
                        <div class="data-section-header" onclick="toggleSection('webhook-logs')">
                            <div class="data-section-title">üìã Logs d'envoi</div>
                            <div class="data-section-badge">Historique</div>
                        </div>
                        <div class="data-section-content" id="webhook-logs">
                            <div id="webhookLogs">Aucun envoi effectu√©</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Parcours -->
            <div id="parcours" class="tab-content">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number" id="parcoursCount">0</div>
                        <div class="stat-label">Parcours actifs</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="sessionsCount">0</div>
                        <div class="stat-label">Sessions contr√¥le</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="progressCount">0</div>
                        <div class="stat-label">Progressions</div>
                    </div>
                </div>
                
                <div class="section">
                    <div class="toolbar">
                        <h3>üèÉ Parcours commenc√©s</h3>
                        <button class="btn" onclick="refreshParcours()">üîÑ Actualiser</button>
                    </div>
                    <div id="parcoursContent"></div>
                </div>
            </div>
            
            <!-- LocalStorage -->
            <div id="localStorage" class="tab-content">
                <div class="toolbar">
                    <input type="text" class="search-box" id="localStorageSearch" placeholder="üîç Rechercher..." oninput="filterLocalStorage()">
                    <div>
                        <button class="btn" onclick="refreshLocalStorage()">üîÑ Actualiser</button>
                        <button class="btn danger" onclick="clearLocalStorage()">üóëÔ∏è Vider</button>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üíæ LocalStorage</h3>
                    <div id="localStorageContent"></div>
                </div>
            </div>
            
            <!-- IndexedDB -->
            <div id="indexedDB" class="tab-content">
                <div class="toolbar">
                    <select id="dbSelect" onchange="loadDatabase()">
                        <option value="">S√©lectionner base de donn√©es</option>
                    </select>
                    <button class="btn" onclick="refreshIndexedDB()">üîÑ Actualiser</button>
                </div>
                
                <div id="indexedDBContent"></div>
            </div>
            
            <!-- Photos -->
            <div id="photos" class="tab-content">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number" id="totalPhotos">0</div>
                        <div class="stat-label">Total photos</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="totalPhotoSize">0 MB</div>
                        <div class="stat-label">Taille totale</div>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üì∏ Photos stock√©es</h3>
                    <button class="btn" onclick="analyzePhotos()">üîç Analyser photos</button>
                    <div id="photosContent"></div>
                </div>
            </div>
            
            <!-- Historique Webhooks -->
            <div id="webhooks" class="tab-content">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number" id="totalWebhooks">0</div>
                        <div class="stat-label">Webhooks envoy√©s</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="uniqueWebhooks">0</div>
                        <div class="stat-label">IDs uniques</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number" id="lastWebhookDate">-</div>
                        <div class="stat-label">Dernier envoi</div>
                    </div>
                </div>
                
                <div class="section">
                    <div class="toolbar">
                        <h3>üöÄ Historique des webhooks</h3>
                        <button class="btn" onclick="refreshWebhooksHistory()">üîÑ Actualiser</button>
                        <button class="btn warning" onclick="clearWebhooksHistory()">üóëÔ∏è Vider historique</button>
                    </div>
                    <div id="webhooksHistoryContent"></div>
                </div>
            </div>
            
            <!-- Outils -->
            <div id="tools" class="tab-content">
                <div class="section">
                    <h3>üßπ Nettoyage</h3>
                    <button class="btn warning" onclick="cleanupData()">üßπ Nettoyer donn√©es</button>
                    <button class="btn danger" onclick="resetAll()">üî¥ Reset complet</button>
                </div>
                
                <div class="section">
                    <h3>üìä Diagnostics</h3>
                    <button class="btn" onclick="runFullDiagnostic()">üîç Diagnostic complet</button>
                    <div id="diagnosticContent"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentTab = 'checkid';
        let checkIdData = {};
        let selectedCheckId = null;
        
        // Configuration des endpoints
        let webhookConfig = {
            baseUrl: 'https://checkeasy-57905.bubbleapps.io',
            environment: 'test', // 'test' ou 'live'
            includeInitialize: true,  // ‚úÖ Inclure /initialize par d√©faut
            checkinEndpoint: '/api/1.1/wf/checkinendpoint',
            checkoutEndpoint: '/api/1.1/wf/checkinendpoint',  // ‚úÖ M√™me endpoint pour les deux
            unifiedEndpoint: '/api/1.1/wf/checkendpoint'  // ‚úÖ Endpoint unifi√©
        };
        
        // === CONFIGURATION ENDPOINT ===
        
        function updateEndpointConfig() {
            const initializeCheckbox = document.getElementById('initializeCheckbox');
            const environmentSelect = document.getElementById('environmentSelect');

            // Mettre √† jour la configuration
            webhookConfig.includeInitialize = initializeCheckbox.checked;
            webhookConfig.environment = environmentSelect.value;

            // Construire les URLs compl√®tes
            const unifiedUrl = buildWebhookUrl('unified');
            const checkinUrl = buildWebhookUrl('checkin');
            const checkoutUrl = buildWebhookUrl('checkout');

            // Mettre √† jour l'affichage avec les trois URLs
            document.getElementById('fullEndpointPreview').innerHTML = `
                <div style="margin-bottom: 12px; padding: 10px; background: #e8f5e9; border-left: 4px solid #4caf50; border-radius: 4px;">
                    <strong style="color: #2e7d32;">üéØ UNIFI√â (Recommand√©):</strong><br>
                    <span style="color: #1976d2; font-family: monospace; font-size: 12px;">${unifiedUrl}</span>
                </div>
                <hr style="margin: 12px 0; border: 1px dashed #ddd;">
                <div style="margin-bottom: 8px; opacity: 0.7;">
                    <strong>üì• CheckIn (D√©pr√©ci√©):</strong><br>
                    <span style="color: #007bff; font-family: monospace; font-size: 11px;">${checkinUrl}</span>
                </div>
                <div style="opacity: 0.7;">
                    <strong>üì§ CheckOut (D√©pr√©ci√©):</strong><br>
                    <span style="color: #28a745; font-family: monospace; font-size: 11px;">${checkoutUrl}</span>
                </div>
            `;
            document.getElementById('currentEndpointDisplay').textContent = getEndpointDisplay();

            console.log('‚öôÔ∏è Configuration endpoint mise √† jour:', webhookConfig);
            console.log('üîó URLs compl√®tes:', { unifiedUrl, checkinUrl, checkoutUrl });
        }
        
        function buildWebhookUrl(type) {
            // Construire l'URL de base selon l'environnement
            const versionSuffix = webhookConfig.environment === 'test' ? 'version-test' : 'version-live';
            const baseUrl = `${webhookConfig.baseUrl}/${versionSuffix}`;

            // Choisir le bon endpoint selon le type
            let endpoint;
            if (type === 'unified') {
                endpoint = webhookConfig.unifiedEndpoint;
            } else if (type === 'checkin') {
                endpoint = webhookConfig.checkinEndpoint;
            } else {
                endpoint = webhookConfig.checkoutEndpoint;
            }

            // Ajouter /initialize si n√©cessaire
            const finalEndpoint = webhookConfig.includeInitialize ? endpoint + '/initialize' : endpoint;

            return baseUrl + finalEndpoint;
        }
        
        function getEndpointDisplay() {
            const initialize = webhookConfig.includeInitialize ? '/initialize' : '';
            const env = webhookConfig.environment === 'test' ? ' (TEST)' : ' (LIVE)';

            const unifiedEndpoint = webhookConfig.unifiedEndpoint.replace('/api/1.1/wf/', '') + initialize;
            const checkinEndpoint = webhookConfig.checkinEndpoint.replace('/api/1.1/wf/', '') + initialize;
            const checkoutEndpoint = webhookConfig.checkoutEndpoint.replace('/api/1.1/wf/', '') + initialize;

            return `üéØ Unifi√©: ${unifiedEndpoint} | CheckIn: ${checkinEndpoint} | CheckOut: ${checkoutEndpoint}${env}`;
        }
        
        function testEndpointConfig() {
            const unifiedUrl = buildWebhookUrl('unified');
            const checkinUrl = buildWebhookUrl('checkin');
            const checkoutUrl = buildWebhookUrl('checkout');

            showAlert('üîß Configuration test√©e', 'info');

            console.log('üß™ TEST CONFIGURATION ENDPOINT:');
            console.log('  - Unified URL:', unifiedUrl);
            console.log('  - CheckIn URL:', checkinUrl);
            console.log('  - CheckOut URL:', checkoutUrl);
            console.log('  - Environment:', webhookConfig.environment);
            console.log('  - Include Initialize:', webhookConfig.includeInitialize);

            // Afficher dans l'interface de debug
            if (document.getElementById('debugSection').style.display !== 'none') {
                document.getElementById('debugContent').innerHTML = `
                    <div style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 5px;">
                        <h4>üîß Test Configuration Endpoint</h4>
                        <div style="margin: 10px 0;">
                            <strong>Environnement:</strong> ${webhookConfig.environment === 'test' ? 'üß™ Test' : 'üöÄ Live'}<br>
                            <strong>Include Initialize:</strong> ${webhookConfig.includeInitialize ? '‚úÖ Oui' : '‚ùå Non'}<br>
                        </div>
                        <div style="margin: 15px 0; padding: 10px; background: white; border-radius: 3px;">
                            <strong>üîó URLs g√©n√©r√©es:</strong><br>
                            ‚Ä¢ <strong style="color: #2e7d32;">üéØ UNIFI√â (Recommand√©):</strong><br>
                              <code style="word-break: break-all; background: #e8f5e9; padding: 4px 6px; border-radius: 2px; border-left: 3px solid #4caf50;">${unifiedUrl}</code><br><br>
                            ‚Ä¢ <strong>üì• CheckIn (D√©pr√©ci√©):</strong><br>
                              <code style="word-break: break-all; background: #e9ecef; padding: 2px 4px; border-radius: 2px; opacity: 0.7;">${checkinUrl}</code><br><br>
                            ‚Ä¢ <strong>üì§ CheckOut (D√©pr√©ci√©):</strong><br>
                              <code style="word-break: break-all; background: #e9ecef; padding: 2px 4px; border-radius: 2px; opacity: 0.7;">${checkoutUrl}</code>
                        </div>
                    </div>
                `;
                document.getElementById('debugSection').style.display = 'block';
            }
        }
        
        function resetEndpointConfig() {
            // Reset aux valeurs par d√©faut
            webhookConfig.environment = 'test';
            webhookConfig.includeInitialize = true;
            
            // Mettre √† jour l'interface
            document.getElementById('initializeCheckbox').checked = true;
            document.getElementById('environmentSelect').value = 'test';
            
            updateEndpointConfig();
            showAlert('üîÑ Configuration r√©initialis√©e', 'success');
        }
        
        function detectEnvironmentFromUrl() {
            // D√©tecter automatiquement l'environnement selon l'URL actuelle
            const currentUrl = window.location.href;
            if (currentUrl.includes('localhost') || currentUrl.includes('127.0.0.1')) {
                webhookConfig.environment = 'test';
                console.log('üîç Environnement d√©tect√©: TEST (localhost)');
            } else if (currentUrl.includes('test') || currentUrl.includes('dev')) {
                webhookConfig.environment = 'test';
                console.log('üîç Environnement d√©tect√©: TEST (URL contient test/dev)');
            } else {
                webhookConfig.environment = 'live';
                console.log('üîç Environnement d√©tect√©: LIVE');
            }
            
            // Mettre √† jour l'interface si elle existe
            const environmentSelect = document.getElementById('environmentSelect');
            if (environmentSelect) {
                environmentSelect.value = webhookConfig.environment;
                updateEndpointConfig();
            }
        }
        
        // === GESTION DES ONGLETS ===
        function showTab(tabName) {
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
            currentTab = tabName;
            
            // Charger les donn√©es
            switch(tabName) {
                case 'checkid':
                    refreshCheckIds();
                    break;
                case 'parcours':
                    refreshParcours();
                    break;
                case 'localStorage':
                    refreshLocalStorage();
                    break;
                case 'indexedDB':
                    refreshIndexedDB();
                    break;
                case 'photos':
                    analyzePhotos();
                    break;
                case 'webhooks':
                    refreshWebhooksHistory();
                    break;
            }
        }
        
        // === HELPER: Extraire TOUS les signalements (toutes pi√®ces) ===
        function extractAllSignalements(sessionData) {
            console.log('üö® Extraction de TOUS les signalements');
            const allSignalements = [];

            // R√©cup√©rer toutes les photos depuis localStorage
            const allPhotos = getAllPhotosFromStorage();

            // Parcourir toutes les pi√®ces dans sessionData
            if (sessionData?.progress?.interactions?.buttonClicks) {
                const pieceIds = new Set();

                // Collecter tous les pieceIds
                Object.values(sessionData.progress.interactions.buttonClicks).forEach(clicks => {
                    if (Array.isArray(clicks)) {
                        clicks.forEach(click => {
                            if (click.pieceId) {
                                pieceIds.add(click.pieceId);
                            }
                        });
                    }
                });

                // Extraire les signalements pour chaque pi√®ce
                pieceIds.forEach(pieceId => {
                    const pieceSignalements = extractRealSignalements(sessionData, allPhotos, pieceId, pieceId);
                    allSignalements.push(...pieceSignalements);
                });
            }

            // Aussi r√©cup√©rer les signalements directs
            if (sessionData?.progress?.interactions?.signalements) {
                Object.entries(sessionData.progress.interactions.signalements).forEach(([key, sig]) => {
                    allSignalements.push({
                        signalement_id: sig.signalementId || key,
                        etape_id: sig.etapeId || null,  // ‚úÖ null au lieu de undefined
                        room_id: sig.pieceId || sig.roomId || null,
                        titre: sig.title || sig.titre || 'Signalement',
                        commentaire: sig.description || sig.commentaire || '',
                        img_url: sig.photos?.[0] || sig.metadata?.imgUrl || sig.imgUrl || null,
                        img_base64: sig.metadata?.imgBase64 || sig.imgBase64 || null,
                        // ‚úÖ CORRECTION: Utiliser metadata.page comme fallback
                        flow_type: sig.metadata?.flowType || sig.flowType || sig.metadata?.page || 'checkin',
                        origine: sig.metadata?.origine || sig.origine || 'CLIENT',
                        status: sig.status === 'resolved' ? 'RESOLU' : 'A_TRAITER',
                        priorite: sig.severity === 'high' || sig.severity === 'critical',
                        created_at: sig.createdAt || sig.created_at || new Date().toISOString(),
                        updated_at: sig.updatedAt || sig.updated_at || new Date().toISOString()
                    });
                });
            }

            console.log(`‚úÖ Total signalements extraits: ${allSignalements.length}`);
            return allSignalements;
        }

        // === HELPER: Formater une pi√®ce pour le webhook ===
        function formatPieceForWebhook(piece, flowType) {
            return {
                piece_id: piece.id,
                nom: piece.nom,
                status: piece.etat_utilisateur || 'non_defini',

                // üìã √âtapes compl√®tes avec toutes les donn√©es utilisateur
                etapes: piece.etapes.map(etape => ({
                    etape_id: etape.etape_id,
                    type: etape.type,
                    etape_type: etape.etape_type || flowType,
                    status: etape.status,
                    timestamp: etape.timestamp,
                    is_todo: etape.is_todo || false,
                    todo_title: etape.todo_title || '',

                    // üì∑ Donn√©es photos (si type = photo_taken)
                    ...(etape.type === 'photo_taken' && {
                        photo_id: etape.photo_id,
                        photo_url: etape.photo_url || '',
                        photo_base64: etape.photo_base64 || null,
                        validated: etape.validated,
                        retake_count: etape.retake_count || 0
                    }),

                    // üîò Donn√©es boutons (si type = button_click)
                    ...(etape.type === 'button_click' && {
                        action: etape.action_type,
                        comment: etape.comment || '',
                        photos_attached: etape.photos_attached || []
                    }),

                    // ‚òëÔ∏è Donn√©es checkbox (si type = checkbox)
                    ...(etape.type === 'checkbox' && {
                        checked: etape.checked,
                        label: etape.label || ''
                    }),

                    // üö® Donn√©es signalement (si type = signalement)
                    ...(etape.type === 'signalement' && {
                        comment: etape.comment || '',
                        severity: etape.severity || 'normal',
                        photos: etape.photos || []
                    })
                }))

                // ‚ùå SUPPRIM√â: signalements[] par pi√®ce (pour √©viter duplication)
                // Les signalements sont maintenant UNIQUEMENT dans signalements[] global
            };
        }

        // === HELPER: Extraire les r√©ponses aux questions de sortie ===
        function extractExitQuestions(sessionData) {
            console.log('üéØ Extraction des questions de sortie');
            const exitQuestions = [];

            // R√©cup√©rer les r√©ponses depuis sessionData.progress.interactions.exitQuestions
            if (sessionData?.progress?.interactions?.exitQuestions) {
                const responses = sessionData.progress.interactions.exitQuestions;

                console.log('üìã R√©ponses trouv√©es:', Object.keys(responses).length);

                // Convertir l'objet en tableau
                Object.entries(responses).forEach(([questionID, response]) => {
                    exitQuestions.push({
                        question_id: response.questionID || questionID,
                        question_content: response.questionContent || '',
                        question_type: response.questionType || 'text',

                        // R√©ponse boolean (pour type "boolean")
                        checked: response.checked !== undefined ? response.checked : null,

                        // R√©ponse texte (pour type "text")
                        text_response: response.textResponse || null,

                        // Image
                        has_image: response.hasImage || false,
                        image_base64: response.imageBase64 || null,
                        image_url: response.imageUrl || null,
                        image_photo_id: response.imagePhotoId || null,

                        // Timestamps
                        timestamp: response.timestamp || new Date().toISOString(),
                        updated_at: response.updatedAt || null
                    });
                });
            }

            console.log(`‚úÖ Total questions de sortie extraites: ${exitQuestions.length}`);
            return exitQuestions;
        }

        // === G√âN√âRATION STRUCTURE WEBHOOK OPTIMIS√âE ===
        function generateWebhookData(sessionData, type) {
            console.log(`üöÄ G√©n√©ration ${type} - Structure optimis√©e et lisible`);

            if (!sessionData) {
                console.warn('‚ö†Ô∏è sessionData undefined, utilisation de donn√©es par d√©faut');
                sessionData = createTestData(type);
            }

            // üéØ SI TYPE = 'unified', g√©n√©rer TOUTES LES DONN√âES dans CHECKIN
            if (type === 'unified') {
                console.log('üéØ Mode UNIFI√â - TOUTES les donn√©es (checkin + checkout) regroup√©es dans CHECKIN');

                // Extraire les informations de base (communes)
                const userVerificationData = extractUserVerificationData(sessionData);
                const parcoursLogementInfo = extractParcoursLogementInfo(sessionData);
                const checkID = generateUniqueWebhookId(selectedCheckId);

                // ‚úÖ EXTRAIRE TOUTES LES PI√àCES SANS FILTRAGE (type='unified' pour tout inclure)
                const allPieces = extractPiecesNewFormat(sessionData, 'unified');
                console.log('üì¶ TOUTES les pi√®ces extraites:', allPieces.length, 'pi√®ces');

                // üîç DEBUG: Afficher les flowTypes de toutes les √©tapes
                console.log('üîç DEBUG: Analyse des flowTypes dans allPieces:');
                allPieces.forEach((piece, idx) => {
                    console.log(`  Pi√®ce ${idx} (${piece.nom}): ${piece.etapes.length} √©tapes`);
                    const flowTypeCounts = {};
                    piece.etapes.forEach(etape => {
                        const ft = etape.etape_type || 'undefined';
                        flowTypeCounts[ft] = (flowTypeCounts[ft] || 0) + 1;
                    });
                    console.log(`    FlowTypes:`, flowTypeCounts);
                });

                // ‚úÖ NOUVEAU: Tout mettre dans checkin (pas de s√©paration)
                const piecesCheckin = allPieces.filter(piece => piece.etapes.length > 0);

                console.log('üì• TOUTES les pi√®ces dans CHECKIN:', piecesCheckin.length, 'pi√®ces,',
                    piecesCheckin.reduce((sum, p) => sum + p.etapes.length, 0), '√©tapes');

                const statsCheckin = calculateGlobalStats(piecesCheckin);

                // Extraire les signalements (tous)
                const allSignalements = extractAllSignalements(sessionData);

                // Extraire les questions de sortie
                const exitQuestions = extractExitQuestions(sessionData);

                // üéØ D√âTERMINER SI ON A DES DONN√âES
                const hasCheckinData = piecesCheckin.some(p => p.etapes && p.etapes.length > 0);

                console.log('üéØ Donn√©es disponibles:', {
                    hasCheckinData,
                    checkinPieces: piecesCheckin.length,
                    checkinEtapes: piecesCheckin.reduce((sum, p) => sum + (p.etapes?.length || 0), 0),
                    exitQuestions: exitQuestions.length,
                    signalements: allSignalements.length
                });

                // üì¶ STRUCTURE SIMPLIFI√âE - TOUT DANS CHECKIN
                const payload = {
                    // üÜî VERSION
                    webhook_version: "2.0",
                    schema: "unified_all_in_checkin",

                    // üÜî IDENTIFIANTS
                    checkID: checkID,
                    parcours_id: parcoursLogementInfo.parcours_id || null,
                    logement_id: parcoursLogementInfo.logement_id || null,
                    logement_name: parcoursLogementInfo.logement_name || null,

                    // üë§ AGENT
                    agent: {
                        id: userVerificationData.user_info?.phone || null,
                        firstname: userVerificationData.user_info?.firstName || null,
                        lastname: userVerificationData.user_info?.lastName || null,
                        phone: userVerificationData.user_info?.phone || null,
                        type: userVerificationData.user_info?.type || "CLIENT",
                        type_label: userVerificationData.user_info?.type === 'CLIENT' ? 'Voyageur' : 'Agent',
                        verification_status: userVerificationData.verification_status || null
                    },

                    // üìä PARCOURS
                    parcours: {
                        id: parcoursLogementInfo.parcours_id || null,
                        name: parcoursLogementInfo.parcours_name || null,
                        type: "üè† Contr√¥le logement",
                        start_time: sessionData.startTime || new Date().toISOString(),
                        current_time: new Date().toISOString(),
                        duration_minutes: 0,
                        completion_percentage: Math.round(statsCheckin.completion_rate || 0),
                        total_pieces: piecesCheckin.length,
                        completed_pieces: 0,
                        pieces_with_issues: allSignalements.length
                    },

                    // üì• CHECKIN - CONTIENT TOUTES LES DONN√âES (checkin + checkout)
                    checkin: hasCheckinData ? {
                        pieces: piecesCheckin.map(piece => formatPieceForWebhook(piece, 'unified')),
                        stats: statsCheckin,
                        timestamp: sessionData.checkinTimestamp || sessionData.startTime || new Date().toISOString()
                    } : null,

                    // üì§ CHECKOUT - VIDE (toutes les donn√©es sont dans checkin)
                    checkout: null,

                    // üö® SIGNALEMENTS (tous)
                    signalements: allSignalements,

                    // üéØ QUESTIONS DE SORTIE
                    exit_questions: exitQuestions,

                    // üìã T√ÇCHES - VIDE (simplification)
                    taches: {},

                    // üìä PROGRESSION - VIDE (simplification)
                    progression: {},

                    // üìä STATS GLOBALES
                    stats: {
                        total_pieces: piecesCheckin.length,
                        total_photos: statsCheckin.total_photos,
                        total_signalements: allSignalements.length,
                        total_exit_questions: exitQuestions.length,
                        completion_rate: Math.round(statsCheckin.completion_rate || 0)
                    }
                };

                return payload;
            }

            // üì¶ MODE NORMAL (checkin OU checkout s√©par√©)
            // Extraire les informations de base
            const userVerificationData = extractUserVerificationData(sessionData);
            const parcoursLogementInfo = extractParcoursLogementInfo(sessionData);
            const checkID = generateUniqueWebhookId(selectedCheckId);

            // Extraire les pi√®ces avec leurs donn√©es
            const pieces = extractPiecesNewFormat(sessionData, type);

            // Calculer les statistiques globales
            const stats = calculateGlobalStats(pieces);

            // üì¶ STRUCTURE WEBHOOK CLAIRE ET ORGANIS√âE
            const webhookData = {
                // üÜî IDENTIFIANTS
                check_id: checkID,
                parcours_id: parcoursLogementInfo.parcours_id || "test-parcours-001",
                logement_id: parcoursLogementInfo.logement_id || "test-logement-001",

                // üë§ AGENT
                agent: {
                    phone: userVerificationData.user_info?.phone || "071234567",
                    firstname: userVerificationData.user_info?.firstName || "Agent",
                    lastname: userVerificationData.user_info?.lastName || "Test",
                    type: userVerificationData.user_info?.type || "AGENT"
                },

                // üìä R√âSUM√â GLOBAL
                summary: {
                    type: type, // "checkin" ou "checkout"
                    timestamp: new Date().toISOString(),
                    total_pieces: stats.total_pieces,
                    total_photos: stats.total_photos,
                    total_tasks: stats.total_tasks,
                    completion_rate: stats.completion_rate
                },

                // üè† PI√àCES (donn√©es principales)
                pieces: pieces.map(piece => ({
                    piece_id: piece.id,
                    nom: piece.nom,
                    status: piece.etat_utilisateur || 'non_defini',

                    // üìã √âtapes compl√®tes avec toutes les donn√©es utilisateur
                    etapes: piece.etapes.map(etape => ({
                        etape_id: etape.etape_id,
                        type: etape.type,
                        etape_type: etape.etape_type || type,  // ‚úÖ "checkin" ou "checkout"
                        status: etape.status,
                        timestamp: etape.timestamp,
                        is_todo: etape.is_todo || false,  // ‚úÖ Indique si c'est une t√¢che √† faire
                        todo_title: etape.todo_title || '',  // ‚úÖ Titre de la t√¢che depuis l'API

                        // üì∑ Donn√©es photos (si type = photo_taken)
                        ...(etape.type === 'photo_taken' && {
                            photo_id: etape.photo_id,
                            photo_url: etape.photo_url || '',
                            photo_base64: etape.photo_base64 || null,
                            validated: etape.validated,
                            retake_count: etape.retake_count || 0
                        }),

                        // üîò Donn√©es boutons (si type = button_click)
                        ...(etape.type === 'button_click' && {
                            action: etape.action_type,
                            comment: etape.comment || '',  // ‚úÖ Commentaire utilisateur
                            photos_attached: etape.photos_attached || []  // ‚úÖ Photos li√©es au bouton
                        }),

                        // ‚òëÔ∏è Donn√©es checkbox (si type = checkbox)
                        ...(etape.type === 'checkbox' && {
                            checked: etape.checked,
                            label: etape.label || ''
                        }),

                        // üö® Donn√©es signalement (si type = signalement)
                        ...(etape.type === 'signalement' && {
                            comment: etape.comment || '',
                            severity: etape.severity || 'normal',
                            photos: etape.photos || []
                        })
                    })),

                    // üö® Signalements (si pr√©sents)
                    ...(piece.signalements && piece.signalements.length > 0 && {
                        signalements: piece.signalements.map(sig => ({
                            id: sig.id,
                            description: sig.description,
                            comment: sig.comment || '',  // ‚úÖ Commentaire du signalement
                            photo_url: sig.photo_url,
                            photo_base64: sig.photo_base64 || null,  // ‚úÖ Image en base64
                            timestamp: sig.timestamp
                        }))
                    })
                }))
            };

            console.log(`‚úÖ ${type} g√©n√©r√© (structure optimis√©e):`);
            console.log(`   üìä ${stats.total_pieces} pi√®ces`);
            console.log(`   üì∑ ${stats.total_photos} photos`);
            console.log(`   ‚úÖ ${stats.total_tasks} t√¢ches`);

            return webhookData;
        }

        // üìä Calculer les statistiques globales
        function calculateGlobalStats(pieces) {
            let total_photos = 0;
            let total_tasks = 0;
            let completed_tasks = 0;

            pieces.forEach(piece => {
                piece.etapes.forEach(etape => {
                    total_tasks++;
                    if (etape.status === 'completed' || etape.status === 'validated') {
                        completed_tasks++;
                    }
                    if (etape.type === 'photo_taken') {
                        total_photos++;
                    }
                });
            });

            return {
                total_pieces: pieces.length,
                total_photos,
                total_tasks,
                completed_tasks,
                completion_rate: total_tasks > 0 ? Math.round((completed_tasks / total_tasks) * 100) : 0
            };
        }
        
        // üî• NOUVELLE FONCTION pour extraire l'avancement complet du parcours
        function extractParcoursProgress(sessionData, type) {
            console.log(`üîç Extraction avancement complet du parcours (${type})`);
            
            const progress = {
                start_time: null,
                duration_minutes: 0,
                completion_percentage: 0,
                total_pieces: 0,
                completed_pieces: 0,
                pieces_with_issues: 0,
                total_button_clicks: 0,
                total_photos_taken: 0,
                total_checkboxes: 0,
                total_signalements: 0,
                navigation_history: [],
                time_spent_per_piece: {},
                data_sources: []
            };
            
            // 1. Analyser les button clicks pour trouver le d√©but et compter les interactions
            if (sessionData.progress?.interactions?.buttonClicks) {
                progress.data_sources.push('buttonClicks');
                const allClicks = Object.values(sessionData.progress.interactions.buttonClicks).flat();
                progress.total_button_clicks = allClicks.length;
                
                // Trouver le premier timestamp (d√©but du parcours)
                const timestamps = allClicks.map(click => new Date(click.timestamp)).filter(date => !isNaN(date));
                if (timestamps.length > 0) {
                    progress.start_time = new Date(Math.min(...timestamps)).toISOString();
                    const now = new Date();
                    const startTime = new Date(progress.start_time);
                    progress.duration_minutes = Math.round((now - startTime) / (1000 * 60));
                }
            }
            
            // 2. Analyser les photos prises
            if (sessionData.progress?.interactions?.photosTaken) {
                progress.data_sources.push('photosTaken');
                const allPhotos = Object.values(sessionData.progress.interactions.photosTaken).flat();
                progress.total_photos_taken = allPhotos.filter(photo => photo && photo.photoId).length;
            }
            
            // 3. Analyser les checkboxes
            if (sessionData.progress?.interactions?.checkboxStates) {
                progress.data_sources.push('checkboxStates');
                progress.total_checkboxes = Object.keys(sessionData.progress.interactions.checkboxStates).length;
            }
            
            // 4. Analyser les signalements
            if (sessionData.progress?.interactions?.signalements) {
                progress.data_sources.push('signalements');
                progress.total_signalements = Object.keys(sessionData.progress.interactions.signalements).length;
            }
            
            // 5. Analyser les √©tats des pi√®ces
            if (sessionData.progress?.pieceStates) {
                progress.data_sources.push('pieceStates');
                const pieceStates = Object.values(sessionData.progress.pieceStates);
                progress.total_pieces = pieceStates.length;
                progress.completed_pieces = pieceStates.filter(piece => 
                    piece.status === 'completed' || piece.completionPercentage === 100
                ).length;
                progress.pieces_with_issues = pieceStates.filter(piece => 
                    piece.signalementsCount > 0
                ).length;
                
                // Calculer le pourcentage global
                if (progress.total_pieces > 0) {
                    progress.completion_percentage = Math.round(
                        (progress.completed_pieces / progress.total_pieces) * 100
                    );
                }
                
                // Temps pass√© par pi√®ce
                pieceStates.forEach(piece => {
                    if (piece.pieceId && sessionData.progress?.navigation?.timeSpentPerPiece?.[piece.pieceId]) {
                        progress.time_spent_per_piece[piece.pieceId] = 
                            sessionData.progress.navigation.timeSpentPerPiece[piece.pieceId];
                    }
                });
            }
            
            // 6. Analyser l'historique de navigation
            if (sessionData.progress?.navigation?.navigationHistory) {
                progress.data_sources.push('navigation');
                progress.navigation_history = sessionData.progress.navigation.navigationHistory;
            }
            
            // 7. Utiliser les statistiques globales si disponibles
            if (sessionData.progress?.statistics) {
                progress.data_sources.push('globalStatistics');
                
                // Compl√©ter avec les donn√©es statistiques globales
                const stats = sessionData.progress.statistics;
                progress.completion_percentage = stats.progressPercentage || progress.completion_percentage;
                progress.total_photos_taken = Math.max(stats.photosTaken || 0, progress.total_photos_taken);
                progress.total_checkboxes = Math.max(stats.totalCheckboxes || 0, progress.total_checkboxes);
                progress.total_signalements = Math.max(stats.totalSignalements || 0, progress.total_signalements);
            }
            
            console.log(`üìä Avancement extrait:`, {
                completion: `${progress.completion_percentage}%`,
                pieces: `${progress.completed_pieces}/${progress.total_pieces}`,
                interactions: progress.total_button_clicks,
                photos: progress.total_photos_taken,
                duration: `${progress.duration_minutes}min`,
                sources: progress.data_sources.join(', ')
            });
            
            return progress;
        }
        
        function extractPiecesNewFormat(sessionData, type) {
            const pieces = [];
            
            if (!sessionData) {
                console.warn('‚ö†Ô∏è Pas de sessionData, retour de pi√®ces vides');
                return pieces;
            }
            
            console.log('üîç EXTRACTION VRAIES DONN√âES - sessionData:', sessionData);
            
            // Extraire les vraies interactions utilisateur
            const roomStates = extractRoomStatesFromSession(sessionData);
            console.log('üè† √âtats des pi√®ces extraits depuis session:', roomStates);
            
            // Extraire les photos r√©elles depuis localStorage
            const allPhotosFromStorage = getAllPhotosFromStorage();
            console.log('üì∏ Photos trouv√©es dans localStorage:', allPhotosFromStorage.length);
            
            // Si on a des interactions de pi√®ces, les utiliser
            if (Object.keys(roomStates).length > 0) {
                Object.entries(roomStates).forEach(([pieceId, pieceInfo]) => {
                    const pieceData = {
                        id: pieceId,
                        nom: pieceInfo.nom || getPieceName(pieceId),
                        etat_utilisateur: pieceInfo.etat_utilisateur || 'non_defini',
                        statut_validation: getStatutValidationFromEtat(pieceInfo.etat_utilisateur),
                        etapes: extractRealEtapes(sessionData, pieceId, type),
                        signalements: extractRealSignalements(sessionData, allPhotosFromStorage, pieceId, pieceInfo.nom)
                    };
                    
                    pieces.push(pieceData);
                });
            } else {
                console.warn('‚ö†Ô∏è Aucune interaction trouv√©e, utilisation des pi√®ces par d√©faut avec donn√©es r√©elles');
                
                // Utiliser les pi√®ces standard mais avec les vraies donn√©es disponibles
                const standardRooms = [
                    { id: generateUniquePieceId(), nom: "Chambre" },
                    { id: generateUniquePieceId(), nom: "Cuisine" }, 
                    { id: generateUniquePieceId(), nom: "Salle de Bain & Toilettes" },
                    { id: generateUniquePieceId(), nom: "Salon" }
                ];
                
                standardRooms.forEach((room) => {
                    const pieceData = {
                        id: room.id,
                        nom: room.nom,
                        etat_utilisateur: 'non_defini',
                        statut_validation: 'en_attente',
                        etapes: extractRealEtapes(sessionData, room.id, type),
                        signalements: extractRealSignalements(sessionData, allPhotosFromStorage, room.id, room.nom)
                    };
                    
                    pieces.push(pieceData);
                });
            }
            
            console.log(`‚úÖ ${pieces.length} pi√®ces extraites depuis donn√©es r√©elles`);
            return pieces;
        }

        /**
         * üîÑ D√©duplique les √©tapes bas√©es sur etape_id + type
         * Garde la version la plus r√©cente en cas de doublon
         */
        function deduplicateEtapes(etapes) {
            const etapeMap = new Map();
            const duplicates = [];

            etapes.forEach((etape, index) => {
                // Cr√©er une cl√© unique bas√©e sur etape_id + type
                const key = `${etape.etape_id}_${etape.type}`;

                if (etapeMap.has(key)) {
                    // Doublon d√©tect√© !
                    const existing = etapeMap.get(key);
                    const existingTimestamp = new Date(existing.timestamp || 0);
                    const currentTimestamp = new Date(etape.timestamp || 0);

                    duplicates.push({
                        etape_id: etape.etape_id,
                        type: etape.type,
                        existing_timestamp: existing.timestamp,
                        duplicate_timestamp: etape.timestamp
                    });

                    // Garder la version la plus r√©cente ET fusionner les photos
                    if (currentTimestamp > existingTimestamp) {
                        console.log(`üîÑ Doublon d√©tect√© pour ${key}: Remplacement par version plus r√©cente`, {
                            ancien: existing.timestamp,
                            nouveau: etape.timestamp
                        });

                        // üîß FIX: Fusionner les photos de l'ancienne version dans la nouvelle
                        if (existing.photos_attached && existing.photos_attached.length > 0) {
                            if (!etape.photos_attached) {
                                etape.photos_attached = [];
                            }
                            // Ajouter les photos de l'ancienne version qui ne sont pas d√©j√† dans la nouvelle
                            existing.photos_attached.forEach(oldPhoto => {
                                const photoExists = etape.photos_attached.some(p => p.photo_id === oldPhoto.photo_id);
                                if (!photoExists) {
                                    etape.photos_attached.push(oldPhoto);
                                    console.log(`  üì∏ Photo fusionn√©e depuis ancienne version: ${oldPhoto.photo_id}`);
                                }
                            });
                            // Mettre √† jour le compteur
                            etape.photos_count = etape.photos_attached.length;
                        }

                        etapeMap.set(key, etape);
                    } else {
                        console.log(`üîÑ Doublon d√©tect√© pour ${key}: Conservation de la version existante`, {
                            existant: existing.timestamp,
                            ignor√©: etape.timestamp
                        });

                        // üîß FIX: Fusionner les photos de la nouvelle version dans l'ancienne
                        if (etape.photos_attached && etape.photos_attached.length > 0) {
                            if (!existing.photos_attached) {
                                existing.photos_attached = [];
                            }
                            // Ajouter les photos de la nouvelle version qui ne sont pas d√©j√† dans l'ancienne
                            etape.photos_attached.forEach(newPhoto => {
                                const photoExists = existing.photos_attached.some(p => p.photo_id === newPhoto.photo_id);
                                if (!photoExists) {
                                    existing.photos_attached.push(newPhoto);
                                    console.log(`  üì∏ Photo fusionn√©e depuis nouvelle version: ${newPhoto.photo_id}`);
                                }
                            });
                            // Mettre √† jour le compteur
                            existing.photos_count = existing.photos_attached.length;
                        }
                    }
                } else {
                    // Premi√®re occurrence, on l'ajoute
                    etapeMap.set(key, etape);
                }
            });

            // Afficher un rapport des doublons
            if (duplicates.length > 0) {
                console.warn(`‚ö†Ô∏è ${duplicates.length} doublons d√©tect√©s et supprim√©s:`);
                console.table(duplicates);
            }

            // Convertir la Map en Array
            return Array.from(etapeMap.values());
        }

        function generateUniquePieceId() {
            return `${Date.now()}x${Math.random().toString().substr(2, 15)}`;
        }
        
        function getStatutValidationFromEtat(etat) {
            switch(etat) {
                case 'correct': return 'valid√©';
                case 'deplorable': 
                case 'probleme': return 'probl√®me_d√©tect√©';
                default: return 'en_attente';
            }
        }
        
        function extractRealEtapes(sessionData, pieceId, type) {
            console.log(`üîç Extraction √©tapes enrichies pour piece ${pieceId} (type=${type})`);
            const etapes = [];
            const etapeIdMap = {}; // Pour tracer les vrais etapeId

            // üö® DIAGNOSTIC: D√©tecter les probl√®mes d'etapeId dupliqu√©s avec pieceId
            let etapeIdIssuesCount = 0;
            const diagnosticInfo = {
                piece_id: pieceId,
                button_clicks_issues: [],
                photos_issues: [],
                total_issues: 0
            };

            console.log(`üî¨ DIAGNOSTIC pour piece ${pieceId}:`);

            // üîç DEBUG: V√©rifier les interactions disponibles
            const hasButtonClicks = !!sessionData.progress?.interactions?.buttonClicks;
            const hasPhotosTaken = !!sessionData.progress?.interactions?.photosTaken;
            console.log(`  üìä Interactions disponibles: buttonClicks=${hasButtonClicks}, photosTaken=${hasPhotosTaken}`);

            // 1. ‚úÖ BUTTON CLICKS - Analyser toutes les interactions de boutons
            if (sessionData.progress?.interactions?.buttonClicks) {
                Object.entries(sessionData.progress.interactions.buttonClicks).forEach(([key, clickArray]) => {
                    // V√©rifier si cette interaction concerne cette pi√®ce
                    const belongsToPiece = key.includes(pieceId) || clickArray.some(click => click.pieceId === pieceId);

                    if (belongsToPiece) {
                        clickArray.forEach((click, index) => {
                            // üéØ FILTRAGE PAR TYPE (checkin/checkout/unified)
                            // ‚úÖ CORRECTION: Utiliser metadata.page comme fallback si flowType n'existe pas
                            const clickFlowType = click.metadata?.flowType ||
                                                  click.flowType ||
                                                  click.metadata?.page ||  // ‚Üê NOUVEAU: fallback sur page
                                                  'checkin';

                            // üîç DEBUG: Log du flowType d√©tect√©
                            if (!click.metadata?.flowType && click.metadata?.page) {
                                console.log(`  ‚ÑπÔ∏è Click flowType d√©tect√© via metadata.page: ${clickFlowType}`);
                            }

                            // Si type = 'unified', on prend tout
                            // Sinon, on filtre par flowType
                            if (type !== 'unified' && clickFlowType !== type) {
                                console.log(`‚è≠Ô∏è Skip click (flowType=${clickFlowType}, type=${type})`);
                                return; // Skip cette √©tape
                            }

                            // ‚úÖ FILTRAGE PAR PI√àCE: Ne garder que les √©tapes de CETTE pi√®ce
                            if (click.pieceId && click.pieceId !== pieceId) {
                                console.log(`‚è≠Ô∏è Skip click (pieceId=${click.pieceId}, expected=${pieceId})`);
                                return; // Skip cette √©tape
                            }
                            // ‚úÖ CORRECTION: Extraire le vrai ID depuis les interactions
                            // Ordre de priorit√©: etapeId (si valide) > buttonId > taskId > metadata.etapeId
                            let rawEtapeId = null;

                            // 1. Essayer etapeId s'il est au bon format
                            if (click.etapeId && /^\d+x\d+$/.test(click.etapeId)) {
                                rawEtapeId = click.etapeId;
                            }
                            // 2. Sinon, essayer buttonId (souvent le vrai ID pour les button_click)
                            else if (click.buttonId && /^\d+x\d+$/.test(click.buttonId)) {
                                rawEtapeId = click.buttonId;
                            }
                            // 3. Sinon, essayer taskId
                            else if (click.taskId && /^\d+x\d+$/.test(click.taskId)) {
                                rawEtapeId = click.taskId;
                            }
                            // 4. Sinon, essayer metadata.etapeId
                            else if (click.metadata?.etapeId && /^\d+x\d+$/.test(click.metadata?.etapeId)) {
                                rawEtapeId = click.metadata.etapeId;
                            }

                            // üîç DIAGNOSTIC: V√©rifier le format de l'ID
                            console.log(`üîç DIAGNOSTIC ETAPE ID:`, {
                                rawEtapeId,
                                'click.etapeId': click.etapeId,
                                'click.buttonId': click.buttonId,
                                'click.taskId': click.taskId,
                                'click.metadata?.etapeId': click.metadata?.etapeId,
                                'Format valide': /^\d+x\d+$/.test(rawEtapeId)
                            });

                            // üéØ FALLBACK: Si rawEtapeId n'est pas au bon format, chercher dans l'API
                            if (!rawEtapeId || !/^\d+x\d+$/.test(rawEtapeId)) {
                                console.warn(`‚ö†Ô∏è etapeId invalide (${rawEtapeId}), recherche dans l'API...`);

                                // Chercher l'etapeID dans l'API en utilisant le taskId ou buttonId
                                const searchId = click.taskId || click.buttonId;
                                if (sessionData?.parcoursData?.piece) {
                                    for (const piece of sessionData.parcoursData.piece) {
                                        if (piece.etapes) {
                                            // Chercher une √©tape qui correspond
                                            const foundEtape = piece.etapes.find(e =>
                                                e.etapeID === searchId ||
                                                e.todoTitle === click.metadata?.label ||
                                                e.todoOrder === click.metadata?.label
                                            );

                                            if (foundEtape) {
                                                rawEtapeId = foundEtape.etapeID;
                                                console.log(`‚úÖ etapeID trouv√© dans l'API: ${rawEtapeId}`);
                                                break;
                                            }
                                        }
                                    }
                                }
                            }

                            // ‚úÖ Utiliser directement rawEtapeId sans transformation
                            const realEtapeId = rawEtapeId;

                            console.log(`‚úÖ ETAPE ID FINAL: "${realEtapeId}" (depuis interaction ou API)`);

                            // ‚úÖ R√©cup√©rer les m√©tadonn√©es depuis l'API
                            const apiMetadata = getEtapeMetadataFromAPI(sessionData, realEtapeId);

                            // ‚úÖ Structure compl√®te avec toutes les donn√©es utilisateur
                            const etapeData = {
                                etape_id: realEtapeId,
                                status: "completed",
                                type: "button_click",
                                // ‚úÖ CORRECTION: Utiliser le flowType r√©el de l'interaction, pas le param√®tre type
                                etape_type: clickFlowType,  // clickFlowType d√©fini ligne 1870
                                action_type: click.actionType || 'validate',
                                timestamp: click.timestamp || new Date().toISOString(),

                                // ‚úÖ M√©tadonn√©es de l'API (isTodo, titre, etc.)
                                is_todo: apiMetadata?.is_todo || click.metadata?.isTodo || false,
                                todo_title: apiMetadata?.todo_title || '',

                                // ‚úÖ Commentaire utilisateur
                                comment: click.metadata?.comment || '',

                                // ‚úÖ Photos attach√©es au bouton
                                photos_attached: click.metadata?.photoUrls || [],
                                photos_count: click.metadata?.photosCount || 0
                            };
                            
                            // Mapper cet etapeId pour les photos/signalements
                            etapeIdMap[realEtapeId] = {
                                pieceId: pieceId,
                                buttonInfo: click,
                                taskId: click.metadata?.originalTaskId || click.taskId
                            };
                            
                            etapes.push(etapeData);
                        });
                    }
                });
            }
            
            // 2. üì∑ PHOTOS TAKEN - Cr√©er une √©tape distincte pour chaque photo
            console.log(`üì∏ Traitement des photos pour piece ${pieceId}`);

            // üîß FIX: R√©cup√©rer les photos depuis DEUX sources
            const photosFromSession = sessionData.progress?.interactions?.photosTaken || {};
            const photosFromLocalStorage = getAllPhotosFromStorage();

            console.log(`  üìä Photos depuis session: ${Object.keys(photosFromSession).length}`);
            console.log(`  üìä Photos depuis localStorage: ${photosFromLocalStorage.length}`);

            // Traiter les photos depuis sessionData
            if (Object.keys(photosFromSession).length > 0) {
                Object.entries(photosFromSession).forEach(([photoKey, photoArray]) => {
                    if (photoArray && Array.isArray(photoArray)) {
                        photoArray.forEach((photo) => {
                            // üîß FIX: Extraire l'etapeId depuis taskId (format: "pieceId_etapeId")
                            let photoEtapeId = null;

                            // 1. Essayer d'extraire depuis taskId (format: "1759732227730x109741529718849540_1759732311386x519469147721302000")
                            if (photo.taskId && photo.taskId.includes('_')) {
                                const parts = photo.taskId.split('_');
                                // Prendre la derni√®re partie qui contient l'etapeId
                                photoEtapeId = parts[parts.length - 1];
                            }

                            // 2. Fallback: essayer metadata.etapeId
                            if (!photoEtapeId || !/^\d+x\d+$/.test(photoEtapeId)) {
                                photoEtapeId = photo.metadata?.photoId || photo.metadata?.etapeId;
                            }

                            // 3. Dernier fallback: etapeId direct (si c'est au bon format)
                            if (!photoEtapeId || !/^\d+x\d+$/.test(photoEtapeId)) {
                                if (photo.etapeId && /^\d+x\d+$/.test(photo.etapeId)) {
                                    photoEtapeId = photo.etapeId;
                                }
                            }

                            console.log(`  üì∑ Photo ${photo.photoId}: taskId="${photo.taskId}", extracted etapeId="${photoEtapeId}", pieceId="${photo.pieceId}"`);

                            // üÜï NOUVEAU: Cr√©er une √©tape distincte pour cette photo
                            // D√©tecter le flowType de la photo
                            const photoFlowType = photo.metadata?.flowType ||
                                                  photo.flowType ||
                                                  photo.metadata?.page ||
                                                  'checkout';

                            // Filtrer par type si n√©cessaire
                            if (type !== 'unified' && photoFlowType !== type) {
                                console.log(`  ‚è≠Ô∏è Skip photo (flowType=${photoFlowType}, type=${type})`);
                                return;
                            }

                            // Cr√©er l'objet photo
                            const photoData = {
                                photo_id: photo.photoId,
                                url: photo.photoData || photo.metadata?.url || '',
                                timestamp: photo.timestamp,
                                validated: photo.validated || false,
                                retake_count: photo.retakeCount || 0
                            };

                            // Cr√©er une nouvelle √©tape pour cette photo
                            const photoEtape = {
                                etape_id: photoEtapeId || `photo-${photo.photoId}`,
                                type: "photo",
                                etape_type: photoFlowType,
                                status: "completed",
                                timestamp: photo.timestamp || new Date().toISOString(),
                                is_todo: false,
                                todo_title: '',
                                action: 'photo_taken',
                                comment: '',
                                photos_attached: [photoData],  // UN SEUL √©l√©ment
                                photos_count: 1
                            };

                            etapes.push(photoEtape);
                            console.log(`  ‚úÖ √âtape photo cr√©√©e: ${photoEtape.etape_id}`);
                        });
                    }
                });
            }

            // üÜï NOUVEAU: Traiter aussi les photos depuis localStorage (fallback)
            if (photosFromLocalStorage.length > 0) {
                console.log(`  üîç Recherche de photos dans localStorage pour les √©tapes de la pi√®ce ${pieceId}`);

                photosFromLocalStorage.forEach((photo) => {
                    const photoEtapeId = photo.taskId || photo.metadata?.etapeId || photo.metadata?.taskId;

                    if (!photoEtapeId) return;

                    // D√©tecter le flowType de la photo
                    const photoFlowType = photo.metadata?.flowType ||
                                          photo.flowType ||
                                          photo.metadata?.page ||
                                          'checkout';

                    // Filtrer par type si n√©cessaire
                    if (type !== 'unified' && photoFlowType !== type) {
                        console.log(`  ‚è≠Ô∏è Skip localStorage photo (flowType=${photoFlowType}, type=${type})`);
                        return;
                    }

                    // V√©rifier si cette photo n'est pas d√©j√† cr√©√©e comme √©tape
                    const alreadyExists = etapes.some(e =>
                        e.type === 'photo' &&
                        e.photos_attached?.some(p => p.photo_id === photo.photoId)
                    );

                    if (!alreadyExists) {
                        console.log(`  ‚úÖ √âtape photo cr√©√©e depuis localStorage: ${photoEtapeId}`);

                        const photoData = {
                            photo_id: photo.photoId,
                            url: photo.dataUrl || photo.url || '',
                            timestamp: photo.timestamp,
                            validated: false,
                            retake_count: 0
                        };

                        // Cr√©er une nouvelle √©tape pour cette photo
                        const photoEtape = {
                            etape_id: photoEtapeId || `photo-${photo.photoId}`,
                            type: "photo",
                            etape_type: photoFlowType,
                            status: "completed",
                            timestamp: photo.timestamp || new Date().toISOString(),
                            is_todo: false,
                            todo_title: '',
                            action: 'photo_taken',
                            comment: '',
                            photos_attached: [photoData],  // UN SEUL √©l√©ment
                            photos_count: 1
                        };

                        etapes.push(photoEtape);
                    }
                });
            }

            console.log(`‚úÖ Traitement des photos termin√© pour piece ${pieceId}`);
            
            // 3. ‚òëÔ∏è CHECKBOX STATES - Analyser les √©tats des checkboxes
            if (sessionData.progress?.interactions?.checkboxStates) {
                Object.entries(sessionData.progress.interactions.checkboxStates).forEach(([checkboxKey, checkboxData]) => {
                    if (checkboxKey.includes(pieceId)) {
                        // üéØ FILTRAGE PAR TYPE (checkin/checkout/unified)
                        // ‚úÖ CORRECTION: Utiliser metadata.page comme fallback si flowType n'existe pas
                        const checkboxFlowType = checkboxData.metadata?.flowType ||
                                                 checkboxData.flowType ||
                                                 checkboxData.metadata?.page ||  // ‚Üê NOUVEAU: fallback sur page
                                                 'checkin';

                        // Si type = 'unified', on prend tout
                        // Sinon, on filtre par flowType
                        if (type !== 'unified' && checkboxFlowType !== type) {
                            console.log(`‚è≠Ô∏è Skip checkbox (flowType=${checkboxFlowType}, type=${type})`);
                            return; // Skip cette checkbox
                        }

                        // üéØ R√©cup√©rer le vrai etapeID depuis checkboxData ou l'API
                        let checkboxEtapeId = checkboxData.etapeId || checkboxData.taskId;

                        // üéØ FALLBACK: Si pas d'etapeId, chercher dans l'API
                        if (!checkboxEtapeId || !/^\d+x\d+$/.test(checkboxEtapeId)) {
                            console.warn(`‚ö†Ô∏è Checkbox etapeId invalide (${checkboxEtapeId}), recherche dans l'API...`);

                            // Extraire le taskId depuis la cl√© composite
                            const keyParts = checkboxKey.split('_');
                            const taskId = keyParts.length > 1 ? keyParts[1] : checkboxKey;

                            if (sessionData?.parcoursData?.piece) {
                                for (const piece of sessionData.parcoursData.piece) {
                                    if (piece.etapes) {
                                        const foundEtape = piece.etapes.find(e => e.etapeID === taskId);
                                        if (foundEtape) {
                                            checkboxEtapeId = foundEtape.etapeID;
                                            console.log(`‚úÖ Checkbox etapeID trouv√© dans l'API: ${checkboxEtapeId}`);
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        // ‚úÖ Structure simplifi√©e et claire
                        const checkboxEtape = {
                            etape_id: checkboxEtapeId || `checkbox-${checkboxKey}`,  // Fallback si vraiment pas trouv√©
                            status: checkboxData.checked ? "completed" : "pending",
                            type: "checkbox",
                            etape_type: checkboxFlowType,  // ‚úÖ Utiliser le flowType r√©el
                            checked: checkboxData.checked || false,
                            timestamp: checkboxData.timestamp || new Date().toISOString(),
                            is_todo: false,  // ‚úÖ Ajouter is_todo
                            todo_title: ''
                        };

                        etapes.push(checkboxEtape);
                    }
                });
            }
            
            // 4. üìù SIGNALEMENTS - Analyser les signalements
            if (sessionData.progress?.interactions?.signalements) {
                Object.entries(sessionData.progress.interactions.signalements).forEach(([signalementKey, signalementData]) => {
                    if (signalementKey.includes(pieceId)) {
                        const signalementEtape = {
                            etape_id: `signalement-${signalementKey}`,
                            status: "completed",
                            type: "signalement",
                            description: `Signalement - ${signalementData.comment || 'Probl√®me signal√©'}`,
                            timestamp: signalementData.timestamp || new Date().toISOString(),
                            
                            // üî• DONN√âES SIGNALEMENT SP√âCIFIQUES
                            signalement_id: signalementKey,
                            comment: signalementData.comment || '',
                            severity: signalementData.severity || 'normal',
                            
                            metadata: {
                                photos_count: signalementData.photos?.length || 0,
                                photo_urls: signalementData.photos || [],
                                piece_name: signalementData.pieceName || getPieceName(pieceId),
                                resolved: signalementData.resolved || false
                            }
                        };
                        
                        etapes.push(signalementEtape);
                    }
                });
            }
            
            // 5. üìä PIECE STATE - Ajouter l'√©tat global de la pi√®ce
            if (sessionData.progress?.pieceStates?.[pieceId]) {
                const pieceState = sessionData.progress.pieceStates[pieceId];
                const pieceEtape = {
                    etape_id: `piece-state-${pieceId}`,
                    status: pieceState.status || "not_started",
                    type: "piece_summary",
                    description: `√âtat global - ${getPieceName(pieceId)}`,
                    timestamp: new Date().toISOString(),
                    
                    // üî• DONN√âES √âTAT PI√àCE
                    completion_percentage: pieceState.completionPercentage || 0,
                    total_interactions: pieceState.totalInteractions || 0,
                    photos_count: pieceState.photosCount || 0,
                    checkboxes_count: pieceState.checkboxesCount || 0,
                    signalements_count: pieceState.signalementsCount || 0,
                    
                    metadata: {
                        piece_status: pieceState.status,
                        completion_percentage: pieceState.completionPercentage,
                        summary: `${pieceState.totalInteractions} interactions, ${pieceState.photosCount} photos`
                    }
                };
                
                etapes.push(pieceEtape);
            }
            
            // Si pas d'interactions du tout, cr√©er une √©tape par d√©faut
            if (etapes.length === 0) {
                etapes.push({
                    etape_id: pieceId,
                    status: "pending",
                    type: "etat_initial", 
                    description: `V√©rification ${getPieceName(pieceId)}`,
                    timestamp: new Date().toISOString(),
                    action_type: 'default',
                    metadata: {
                        default_created: true,
                        piece_name: getPieceName(pieceId)
                    }
                });
            }
            
            // üîç DEBUG: Compter les √©tapes par type avant d√©duplication
            const etapesByType = {};
            const etapesByFlowType = {};
            etapes.forEach(etape => {
                const t = etape.type || 'undefined';
                const ft = etape.etape_type || 'undefined';
                etapesByType[t] = (etapesByType[t] || 0) + 1;
                etapesByFlowType[ft] = (etapesByFlowType[ft] || 0) + 1;
            });
            console.log(`  üìä √âtapes extraites (${etapes.length} total):`, etapesByType);
            console.log(`  üìä Par flowType:`, etapesByFlowType);

            // ‚úÖ D√âDUPLICATION DES √âTAPES
            const etapesDedupliquees = deduplicateEtapes(etapes);
            console.log(`üîÑ D√©duplication: ${etapes.length} √©tapes ‚Üí ${etapesDedupliquees.length} √©tapes uniques (${etapes.length - etapesDedupliquees.length} doublons supprim√©s)`);

            // Trier les √©tapes par timestamp
            etapesDedupliquees.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            // üö® RAPPORT DIAGNOSTIC FINAL COMPLET
            diagnosticInfo.total_issues = etapeIdIssuesCount;
            
            // üìä Afficher aussi les √©tapes disponibles dans l'API pour cette pi√®ce
            console.log(`üìä RAPPORT COMPLET - Piece ${getPieceName(pieceId)} (${pieceId}):`);
            
            if (sessionData?.parcoursData?.piece) {
                const piece = sessionData.parcoursData.piece.find(p => p.pieceID === pieceId);
                if (piece && piece.etapes) {
                    console.log(`üìã √âtapes disponibles dans l'API pour cette pi√®ce:`);
                    piece.etapes.forEach((etape, index) => {
                        console.log(`   ${index + 1}. ${etape.etapeID} - ${etape.isTodo ? '‚úÖ TODO' : 'üì∑ PHOTO'}: ${etape.todoTitle || 'Photo de r√©f√©rence'}`);
                    });
                } else {
                    console.warn(`‚ö†Ô∏è Aucune √©tape trouv√©e dans l'API pour piece ${pieceId}`);
                }
            } else {
                console.warn(`‚ö†Ô∏è Aucune donn√©e parcoursData disponible`);
            }
            
            if (etapeIdIssuesCount > 0) {
                console.error(`üö® PROBL√àMES D√âTECT√âS:`);
                console.error(`   Total probl√®mes: ${etapeIdIssuesCount}`);
                console.error(`   Button clicks avec etapeId=pieceId: ${diagnosticInfo.button_clicks_issues.length}`);
                console.error(`   Photos avec etapeId=pieceId: ${diagnosticInfo.photos_issues.length}`);
                console.table(diagnosticInfo.button_clicks_issues);
                console.table(diagnosticInfo.photos_issues);
                
                console.error(`üîß SOLUTIONS APPLIQU√âES:`);
                console.error(`   ‚úÖ Mapping avec les vrais etapeID de l'API quand possible`);
                console.error(`   ‚úÖ G√©n√©ration d'IDs uniques quand pas de mapping disponible`);
                console.error(`üìã RECOMMANDATION: Corriger l'enregistrement des interactions pour utiliser les vrais etapeID d√®s le d√©part`);
            } else {
                console.log(`‚úÖ DIAGNOSTIC OK: Tous les etapeId sont correctement mapp√©s pour ${getPieceName(pieceId)}`);
            }
            
            console.log(`‚úÖ ${etapesDedupliquees.length} √©tapes extraites pour ${getPieceName(pieceId)} (${etapes.length - etapesDedupliquees.length} doublons supprim√©s)`);
            return etapesDedupliquees;
        }
        
        // üî• FONCTION UTILITAIRE GLOBALE: Nettoyer automatiquement les etapeIDs
        function cleanEtapeId(etapeId) {
            if (!etapeId) return undefined;
            // Extraire seulement la partie au format timestampXrandom
            const etapeIdMatch = etapeId.match(/(\d+x\d+)/);
            const cleanId = etapeIdMatch ? etapeIdMatch[1] : etapeId;
            
            console.log(`üßπ Nettoyage etapeId: "${etapeId}" ‚Üí "${cleanId}"`);
            return cleanId;
        }
        
        // üî• FONCTION DE DIAGNOSTIC: V√©rifier l'origine des donn√©es parcoursData
        function verifyParcoursDataSource(sessionData) {
            console.log('üî¨ DIAGNOSTIC COMPLET - ORIGINE DES DONN√âES parcoursData:');
            
            if (!sessionData?.parcoursData) {
                console.error('‚ùå Aucune donn√©e parcoursData trouv√©e dans sessionData');
                return { isValid: false, source: 'none', reason: 'parcoursData manquant' };
            }
            
            const parcoursData = sessionData.parcoursData;
            
            // V√©rifier la structure pour d√©terminer l'origine
            const diagnostic = {
                hasParcoursId: !!parcoursData.parcourID,
                hasLogementId: !!parcoursData.logementID,
                hasPieces: !!parcoursData.piece && Array.isArray(parcoursData.piece),
                totalPieces: parcoursData.piece?.length || 0,
                totalEtapes: parcoursData.piece?.reduce((acc, p) => acc + (p.etapes?.length || 0), 0) || 0,
                firstPieceId: parcoursData.piece?.[0]?.pieceID || 'N/A',
                firstEtapeId: parcoursData.piece?.[0]?.etapes?.[0]?.etapeID || 'N/A',
                logementName: parcoursData.logementName || 'N/A'
            };
            
            // V√©rifier si c'est des donn√©es API r√©elles ou statiques
            let source = 'unknown';
            let isValid = false;
            
            if (parcoursData.logementName && parcoursData.parcourID && parcoursData.piece) {
                if (parcoursData.logementName.includes('Test') || parcoursData.logementName === 'Villa Oh') {
                    source = 'static_data_json'; // Probablement du fichier Data.json
                } else {
                    source = 'api_endpoint'; // Probablement de l'API r√©elle
                }
                isValid = true;
            }
            
            console.log('üìä DIAGNOSTIC PARCOURSDATA:');
            console.table(diagnostic);
            console.log(`üéØ Source d√©tect√©e: ${source}`);
            console.log(`‚úÖ Donn√©es valides: ${isValid}`);
            
            // Afficher un √©chantillon des etapeID pour v√©rification
            if (parcoursData.piece && parcoursData.piece.length > 0) {
                console.log('üìã √âCHANTILLON ETAPES (pour v√©rification):');
                parcoursData.piece.slice(0, 2).forEach((piece, pieceIndex) => {
                    console.log(`Pi√®ce ${pieceIndex + 1}: ${piece.nom} (${piece.pieceID})`);
                    if (piece.etapes) {
                        piece.etapes.slice(0, 3).forEach((etape, etapeIndex) => {
                            console.log(`  √âtape ${etapeIndex + 1}: ${etape.etapeID} - ${etape.isTodo ? 'TODO' : 'PHOTO'}: ${(etape.todoTitle || 'Photo r√©f√©rence').substring(0, 50)}...`);
                        });
                    }
                });
            }
            
            return { isValid, source, diagnostic };
        }
        
        // üî• FONCTION HELPER: R√©cup√©rer les m√©tadonn√©es d'une √©tape depuis l'API
        function getEtapeMetadataFromAPI(sessionData, etapeId) {
            if (!sessionData?.parcoursData?.piece) return null;

            for (const piece of sessionData.parcoursData.piece) {
                if (piece.etapes) {
                    const etape = piece.etapes.find(e => e.etapeID === etapeId);
                    if (etape) {
                        return {
                            is_todo: etape.isTodo || false,
                            todo_title: etape.todoTitle || '',
                            todo_order: etape.todoOrder || '',
                            image_url: etape.image || '',
                            piece_name: piece.nom || ''
                        };
                    }
                }
            }
            return null;
        }

        // üî• FONCTION DE MAPPING: Trouver le vrai etapeID depuis l'API du parcours
        function findRealEtapeIdFromAPI(sessionData, pieceId, taskContext = null) {
            console.log(`üîç Recherche du vrai etapeID depuis l'API pour piece ${pieceId}`, taskContext);
            
            // üö® V√âRIFICATION CRITIQUE: D'o√π viennent ces donn√©es ?
            const sourceVerification = verifyParcoursDataSource(sessionData);
            if (!sourceVerification.isValid) {
                console.error('‚ùå Donn√©es parcoursData invalides, impossible de faire le mapping');
                return null;
            }
            
            console.log(`üì° Source des donn√©es confirm√©e: ${sourceVerification.source}`);
            
            // Chercher dans les donn√©es du parcours (API)
            if (sessionData?.parcoursData?.piece) {
                const piece = sessionData.parcoursData.piece.find(p => p.pieceID === pieceId);
                if (piece && piece.etapes) {
                    console.log(`‚úÖ Pi√®ce trouv√©e avec ${piece.etapes.length} √©tapes:`, piece.etapes.map(e => ({ etapeID: e.etapeID, isTodo: e.isTodo, todoTitle: e.todoTitle?.substring(0, 30) + '...' })));
                    
                    // Si on a un contexte de t√¢che, essayer de matcher
                    if (taskContext) {
                        // Chercher par type de t√¢che ou titre
                        const matchingEtape = piece.etapes.find(etape => {
                            if (taskContext.todoTitle && etape.todoTitle) {
                                return etape.todoTitle.toLowerCase().includes(taskContext.todoTitle.toLowerCase().substring(0, 10));
                            }
                            if (taskContext.taskType === 'reference-photos' && !etape.isTodo && etape.image) {
                                return true; // Photos de r√©f√©rence
                            }
                            if (taskContext.isTodo === etape.isTodo) {
                                return true;
                            }
                            return false;
                        });
                        
                        if (matchingEtape) {
                            console.log(`üéØ √âtape match√©e par contexte: ${matchingEtape.etapeID}`);
                            return matchingEtape.etapeID;
                        }
                    }
                    
                    // Fallback : retourner la premi√®re √©tape si pas de contexte sp√©cifique
                    if (piece.etapes.length > 0) {
                        console.log(`üîÑ Fallback: utilisation de la premi√®re √©tape ${piece.etapes[0].etapeID}`);
                        return piece.etapes[0].etapeID;
                    }
                }
            }
            
            console.log(`‚ùå Aucun etapeID trouv√© dans l'API pour piece ${pieceId}`);
            return null;
        }
        
        // üî• FONCTION UTILITAIRE GLOBALE: G√©n√©rer un etapeID unique si manquant ou dupliqu√©
        function ensureUniqueEtapeId(rawEtapeId, pieceId, etapeIndex = 0) {
            // Si pas d'etapeId ou si etapeId = pieceId, g√©n√©rer un ID unique
            if (!rawEtapeId || rawEtapeId === pieceId) {
                const timestamp = Date.now();
                const randomSuffix = Math.floor(Math.random() * 1000000000000000000); // 18 chiffres
                const generatedId = `${timestamp}x${randomSuffix}`;
                
                console.log('üîÑ EtapeId manquant ou dupliqu√© avec pieceId - g√©n√©ration automatique:', {
                    pieceId: pieceId,
                    etapeIndex: etapeIndex,
                    originalEtapeId: rawEtapeId,
                    generatedEtapeId: generatedId,
                    reason: rawEtapeId ? 'duplicate_with_piece' : 'missing'
                });
                
                return generatedId;
            }
            
            // Si etapeId existe et est diff√©rent du pieceId, le nettoyer normalement
            return cleanEtapeId(rawEtapeId);
        }
        
        // üî• NOUVELLE FONCTION HELPER pour les descriptions d'√©tapes
        function getEtapeDescription(click) {
            const roomName = click.metadata?.roomName || '';
            const actionType = click.actionType || '';
            const taskType = click.metadata?.taskType || '';
            const comment = click.metadata?.comment || '';
            
            // Descriptions personnalis√©es selon le type d'action
            switch (actionType) {
                case 'correct':
                    return `${actionType} - etat-initial-${click.etapeId}-${actionType}`;
                case 'deplorable':
                    return `${actionType} - etat-initial-${click.etapeId}-${actionType}${comment ? ` (${comment})` : ''}`;
                case 'photo_intent':
                    return `Intention photo - ${taskType} pour ${roomName}`;
                case 'task_complete':
                    return `T√¢che termin√©e - ${taskType} pour ${roomName}`;
                default:
                    return click.action || `${actionType} - ${roomName}`;
            }
        }
        
        function extractRealSignalements(sessionData, allPhotos, pieceId, nomPiece) {
            console.log(`üîç Extraction signalements enrichis pour piece ${pieceId}`);
            const signalements = [];
            
            // 1. üìù SIGNALEMENTS DIRECTS - Chercher dans sessionData.progress.interactions.signalements
            if (sessionData?.progress?.interactions?.signalements) {
                Object.entries(sessionData.progress.interactions.signalements).forEach(([signalementKey, signalementData]) => {
                    if (signalementKey.includes(pieceId) || signalementData.pieceId === pieceId || signalementData.roomId === pieceId) {
                        console.log(`   üìù Signalement direct: ${signalementKey}`, signalementData);

                        // üéØ R√©cup√©rer imgUrl et imgBase64 depuis signalementData
                        let finalImgUrl = signalementData.imgUrl || null;
                        let finalImgBase64 = signalementData.imgBase64 || null;

                        console.log(`   üîç Signalement image data:`, {
                            hasImgUrl: !!finalImgUrl,
                            hasImgBase64: !!finalImgBase64,
                            imgUrlType: finalImgUrl ? (finalImgUrl.startsWith('blob:') ? 'blob' : finalImgUrl.startsWith('http') ? 'url' : 'data') : 'none',
                            imgBase64Length: finalImgBase64?.length
                        });

                        // Si imgUrl est une blob URL ET qu'on n'a pas de base64, chercher dans allPhotos
                        if (finalImgUrl && finalImgUrl.startsWith('blob:') && !finalImgBase64) {
                            console.log(`   üîç imgUrl est une blob URL sans base64, recherche dans allPhotos...`);

                            // Chercher dans allPhotos par signalement_id ou timestamp proche
                            const matchingPhoto = allPhotos.find(photo => {
                                // Chercher par timestamp proche (¬±5 secondes)
                                const photoTime = new Date(photo.timestamp || photo.uploadedAt).getTime();
                                const signalementTime = new Date(signalementData.createdAt || signalementData.created_at).getTime();
                                const timeDiff = Math.abs(photoTime - signalementTime);

                                return timeDiff < 5000 && photo.pieceId === pieceId;
                            });

                            if (matchingPhoto) {
                                console.log(`   ‚úÖ Photo trouv√©e dans allPhotos:`, matchingPhoto.id);

                                // R√©cup√©rer le base64 ou l'URL upload√©e
                                if (matchingPhoto.uploadedUrl) {
                                    finalImgUrl = matchingPhoto.uploadedUrl;
                                    finalImgBase64 = null;
                                } else if (matchingPhoto.photoData) {
                                    // Extraire le base64 pur
                                    if (matchingPhoto.photoData.startsWith('data:image/')) {
                                        finalImgBase64 = matchingPhoto.photoData.split(',')[1] || matchingPhoto.photoData;
                                        finalImgUrl = null;
                                    } else {
                                        finalImgUrl = matchingPhoto.photoData;
                                        finalImgBase64 = null;
                                    }
                                }
                            } else {
                                console.warn(`   ‚ö†Ô∏è Aucune photo trouv√©e dans allPhotos pour ce signalement`);
                            }
                        }

                        // ‚úÖ NOUVELLE STRUCTURE COMPL√àTE
                        signalements.push({
                            // üÜî Identifiants
                            signalement_id: signalementData.id || `signalement-${signalementKey}`,
                            etape_id: signalementData.etapeId || null,
                            room_id: signalementData.roomId || pieceId,

                            // üìù Contenu
                            titre: signalementData.titre || 'Signalement',
                            commentaire: signalementData.commentaire || signalementData.comment || '',

                            // üñºÔ∏è Images (avec base64 r√©cup√©r√©)
                            img_url: finalImgUrl,
                            img_base64: finalImgBase64,

                            // üè∑Ô∏è M√©tadonn√©es
                            // ‚úÖ CORRECTION: Utiliser metadata.page comme fallback
                            flow_type: signalementData.flowType || signalementData.metadata?.page || 'checkin',
                            origine: signalementData.origine || 'CLIENT',
                            status: signalementData.status || 'A_TRAITER',
                            priorite: signalementData.priorite || false,

                            // ‚è∞ Timestamps
                            created_at: signalementData.created_at || new Date().toISOString(),
                            updated_at: signalementData.updated_at || new Date().toISOString(),

                            // üîß Compatibilit√© ancienne structure
                            description: signalementData.titre || 'Signalement',
                            comment: signalementData.commentaire || signalementData.comment || '',
                            timestamp: signalementData.created_at || new Date().toISOString(),
                            severity: signalementData.priorite ? 'high' : 'normal',
                            signalement_type: 'direct'
                        });
                    }
                });
            }
            
            // 2. üì∑ SIGNALEMENTS VIA BUTTON CLICKS avec commentaires et photos
            if (sessionData?.progress?.interactions?.buttonClicks) {
                Object.entries(sessionData.progress.interactions.buttonClicks).forEach(([key, clickArray]) => {
                    const belongsToPiece = key.includes(pieceId) || clickArray.some(click => click.pieceId === pieceId);
                    
                    if (belongsToPiece) {
                        clickArray.forEach(click => {
                            // Si le click a un commentaire ou des photos, c'est un signalement potentiel
                            if (click.metadata?.comment || (click.metadata?.photosCount > 0) || click.metadata?.photoUrls?.length > 0) {
                                console.log(`   üö® Signalement via button click: action="${click.actionType}" comment="${click.metadata?.comment}"`);
                                
                                const photosFromClick = (click.metadata?.photoUrls || []).map((photoInfo, idx) => ({
                                    photo_url: typeof photoInfo === 'string' ? photoInfo : photoInfo.url,
                                    photo_base64: photoInfo.photoData || photoInfo.base64 || null,  // ‚úÖ Image en base64
                                    timestamp: click.timestamp,
                                    etape_id: click.etapeId,
                                    source: 'button_click'
                                }));

                                // ‚úÖ NOUVELLE STRUCTURE COMPL√àTE
                                signalements.push({
                                    // üÜî Identifiants
                                    signalement_id: `signalement-${click.etapeId}`,
                                    etape_id: click.etapeId,
                                    room_id: click.pieceId || pieceId,

                                    // üìù Contenu
                                    titre: click.metadata?.comment || `${click.actionType} - ${click.metadata?.roomName || nomPiece}`,
                                    commentaire: click.metadata?.comment || '',

                                    // üñºÔ∏è Images
                                    img_url: photosFromClick[0]?.photo_url || null,
                                    img_base64: photosFromClick[0]?.photo_base64 || null,

                                    // üè∑Ô∏è M√©tadonn√©es
                                    // ‚úÖ CORRECTION: Utiliser metadata.page comme fallback
                                    flow_type: click.metadata?.flowType || click.metadata?.page || 'checkin',
                                    origine: click.metadata?.userType || 'CLIENT',
                                    status: 'A_TRAITER',
                                    priorite: false,

                                    // ‚è∞ Timestamps
                                    created_at: click.timestamp || new Date().toISOString(),
                                    updated_at: click.timestamp || new Date().toISOString(),

                                    // üîß Compatibilit√© ancienne structure
                                    description: click.metadata?.comment || `${click.actionType} - ${click.metadata?.roomName || nomPiece}`,
                                    comment: click.metadata?.comment || '',
                                    timestamp: click.timestamp || new Date().toISOString(),
                                    severity: 'normal',
                                    signalement_type: 'button_with_issue',
                                    action_type: click.actionType,
                                    button_id: click.buttonId,
                                    photos: photosFromClick
                                });
                            }
                        });
                    }
                });
            }
            
            // 3. üì∏ SIGNALEMENTS VIA PHOTOS avec matching par etapeId
            if (sessionData?.progress?.interactions?.photosTaken) {
                Object.entries(sessionData.progress.interactions.photosTaken).forEach(([photoKey, photoArray]) => {
                    if (photoArray && Array.isArray(photoArray)) {
                        photoArray.forEach(photo => {
                            const belongsToPiece = photo.pieceId === pieceId || 
                                                   photoKey.includes(pieceId) ||
                                                   (photo.metadata?.pieceId === pieceId);
                            
                            if (belongsToPiece) {
                                console.log(`   üì∏ Photo pour signalement: photoId="${photo.photoId}" etapeId="${photo.etapeId}"`);
                                
                                // Chercher si cette photo correspond √† un signalement existant
                                let signalementExists = false;
                                
                                signalements.forEach(signalement => {
                                    if (signalement.etape_id === photo.etapeId ||
                                        signalement.etape_id === photo.metadata?.mappedEtapeId) {
                                        // S'assurer que photos est un tableau
                                        if (!Array.isArray(signalement.photos)) {
                                            signalement.photos = [];
                                        }

                                        // Ajouter cette photo au signalement existant
                                        signalement.photos.push({
                                            url: photo.metadata?.url || `photo-${photo.photoId}` || null,
                                            timestamp: photo.timestamp || null,
                                            photo_id: photo.photoId || null,
                                            etape_id: photo.etapeId || null,
                                            validated: photo.validated || false,
                                            retake_count: photo.retakeCount || 0,
                                            source: 'photo_taken'
                                        });
                                        signalementExists = true;
                                        console.log(`     ‚ûï Ajout√©e √† signalement existant`);
                                    }
                                });
                                
                                // Si pas de signalement correspondant, en cr√©er un nouveau si c'est pertinent
                                if (!signalementExists && (photo.validated === false || photo.retakeCount > 0 || photo.metadata?.comment)) {
                                    console.log(`     üÜï Nouveau signalement cr√©√© pour photo`);

                                    // ‚úÖ NOUVELLE STRUCTURE COMPL√àTE
                                    signalements.push({
                                        // üÜî Identifiants
                                        signalement_id: `signalement-photo-${photo.photoId}`,
                                        etape_id: photo.etapeId || null,  // ‚úÖ null au lieu de undefined
                                        room_id: photo.pieceId || pieceId || null,

                                        // üìù Contenu
                                        titre: photo.metadata?.comment || `Photo non valid√©e - ${photo.metadata?.pieceName || nomPiece}`,
                                        commentaire: photo.metadata?.comment || '',

                                        // üñºÔ∏è Images
                                        img_url: photo.metadata?.url || `photo-${photo.photoId}` || null,
                                        img_base64: photo.photoData || photo.base64 || null,

                                        // üè∑Ô∏è M√©tadonn√©es
                                        // ‚úÖ CORRECTION: Utiliser metadata.page comme fallback
                                        flow_type: photo.metadata?.flowType || photo.metadata?.page || 'checkin',
                                        origine: photo.metadata?.userType || 'CLIENT',
                                        status: 'A_TRAITER',
                                        priorite: photo.retakeCount > 2,

                                        // ‚è∞ Timestamps
                                        created_at: photo.timestamp || new Date().toISOString(),
                                        updated_at: photo.timestamp || new Date().toISOString(),

                                        // üîß Compatibilit√© ancienne structure
                                        description: photo.metadata?.comment || `Photo non valid√©e - ${photo.metadata?.pieceName || nomPiece}`,
                                        comment: photo.metadata?.comment || '',
                                        timestamp: photo.timestamp || new Date().toISOString(),
                                        severity: photo.retakeCount > 2 ? 'high' : 'normal',
                                        signalement_type: 'photo_issue',
                                        photos: [{
                                            url: photo.metadata?.url || `photo-${photo.photoId}`,
                                            timestamp: photo.timestamp,
                                            photo_id: photo.photoId,
                                            etape_id: photo.etapeId,
                                            validated: photo.validated || false,
                                            retake_count: photo.retakeCount || 0,
                                            source: 'photo_taken'
                                        }]
                                    });
                                }
                            }
                        });
                    }
                });
            }
            
            // 4. üñºÔ∏è SIGNALEMENTS DEPUIS LOCALSTORAGE (fallback)
            const photosForPiece = allPhotos.filter(photo => 
                extractPieceIdFromPhoto(photo) === pieceId || 
                photo.pieceId === pieceId ||
                photo.metadata?.pieceId === pieceId
            );
            
            if (photosForPiece.length > 0 && signalements.length === 0) {
                console.log(`   üì± Fallback localStorage: ${photosForPiece.length} photos`);
                
                const groupedPhotos = groupPhotosBySignalement(photosForPiece);
                
                groupedPhotos.forEach((group, index) => {
                    // ‚úÖ NOUVELLE STRUCTURE COMPL√àTE
                    signalements.push({
                        // üÜî Identifiants
                        signalement_id: `signalement-localStorage-${pieceId}-${index}`,
                        etape_id: `localStorage-${pieceId}-${index}`,
                        room_id: pieceId,

                        // üìù Contenu
                        titre: group.commentaire || `Signalement localStorage - ${nomPiece}`,
                        commentaire: group.commentaire || '',

                        // üñºÔ∏è Images
                        img_url: group.photos[0]?.url || null,
                        img_base64: group.photos[0]?.photoData || group.photos[0]?.base64 || null,

                        // üè∑Ô∏è M√©tadonn√©es
                        flow_type: 'checkin',
                        origine: 'CLIENT',
                        status: 'A_TRAITER',
                        priorite: false,

                        // ‚è∞ Timestamps
                        created_at: group.photos[0]?.timestamp || new Date().toISOString(),
                        updated_at: group.photos[0]?.timestamp || new Date().toISOString(),

                        // üîß Compatibilit√© ancienne structure
                        description: group.commentaire || `Signalement localStorage - ${nomPiece}`,
                        comment: group.commentaire || '',
                        timestamp: group.photos[0]?.timestamp || new Date().toISOString(),
                        severity: 'normal',
                        signalement_type: 'localStorage_fallback',
                        photos: group.photos.map(photo => ({
                            url: photo.url,
                            timestamp: photo.timestamp || photo.metadata?.takenAt || new Date().toISOString(),
                            source: 'localStorage'
                        }))
                    });
                });
            }
            
            console.log(`   ‚úÖ ${signalements.length} signalements extraits pour ${nomPiece}`);
            return signalements;
        }
        
        function groupPhotosBySignalement(photos) {
            // Grouper les photos par timestamp similaire (dans les 5 minutes)
            const groups = [];
            
            photos.forEach(photo => {
                const photoTime = new Date(photo.timestamp || photo.metadata?.takenAt);
                
                let foundGroup = groups.find(group => {
                    const groupTime = new Date(group.photos[0].timestamp || group.photos[0].metadata?.takenAt);
                    const timeDiff = Math.abs(photoTime - groupTime) / (1000 * 60); // diff√©rence en minutes
                    return timeDiff <= 5;
                });
                
                if (foundGroup) {
                    foundGroup.photos.push(photo);
                } else {
                    groups.push({
                        commentaire: photo.metadata?.comment || photo.comment || null,
                        photos: [photo]
                    });
                }
            });
            
            return groups;
        }
        
        function getPieceName(pieceId) {
            // Mapping des IDs vers les noms
            const pieceNames = {
                'salon': 'Salon',
                'cuisine': 'Cuisine', 
                'chambre': 'Chambre',
                'sdb': 'Salle de Bain & Toilettes',
                'salle_de_bain': 'Salle de Bain & Toilettes'
            };
            
            // Essayer de deviner depuis l'ID
            const lowerPieceId = pieceId.toLowerCase();
            for (const [key, name] of Object.entries(pieceNames)) {
                if (lowerPieceId.includes(key)) {
                    return name;
                }
            }
            
            return `Pi√®ce ${pieceId.substring(0, 10)}...`;
        }
        
        // Fonctions mock√©es supprim√©es - on utilise maintenant les vraies donn√©es

        // === DONN√âES DE TEST ===
        function createTestData(type) {
            const baseData = {
                timestamp: new Date().toISOString(),
                user_id: 'test-user-001',
                logement_id: 'test-logement-001',
                parcours_id: 'test-parcours-001',
                userInfo: {
                    firstName: 'Jean',
                    lastName: 'Dupont',
                    phone: '+33123456789',
                    type: 'CLIENT',
                    registeredAt: new Date().toISOString()
                },
                parcoursInfo: {
                    id: 'test-parcours-001',
                    name: 'Appartement 2 pi√®ces - Test',
                    logement_id: 'test-logement-001',
                    logement: 'Appartement Test Paris'
                },
                progress: {
                    completedTaskIds: ['task1', 'task2', 'task3'],
                    statistics: {
                        totalPhotos: type === 'checkin' ? 5 : 12,
                        totalInteractions: type === 'checkin' ? 8 : 15
                    },
                    pieceStates: {
                        salon: { totalInteractions: type === 'checkin' ? 3 : 6 },
                        cuisine: { totalInteractions: type === 'checkin' ? 2 : 4 },
                        chambre: { totalInteractions: type === 'checkin' ? 3 : 5 }
                    }
                }
            };
            
            if (type === 'checkin') {
                baseData.sessionPhase = 'checkin';
                baseData.checkType = 'checkin';
            } else {
                baseData.sessionPhase = 'checkout';
                baseData.checkType = 'checkout';
            }
            
            return baseData;
        }

        // === CHECKID BROWSER ===
        async function refreshCheckIds() {
            const select = document.getElementById('checkIdSelect');

            // Afficher un message de chargement
            select.innerHTML = '<option value="">‚è≥ Chargement...</option>';

            // üéØ NOUVEAU: Charger depuis IndexedDB au lieu de localStorage
            const sessions = await getCheckSessionsFromIndexedDB();

            // Vider le s√©lecteur
            select.innerHTML = '<option value="">üÜî S√©lectionner un CheckID</option>';

            const checkIds = Object.keys(sessions);

            if (checkIds.length === 0) {
                select.innerHTML = '<option value="">Aucun CheckID trouv√©</option><option value="test-checkin-001">üß™ Donn√©es de test CheckIn</option><option value="test-checkout-001">üß™ Donn√©es de test CheckOut</option>';
                document.getElementById('checkIdDataContent').innerHTML = '<div class="alert info">Aucune session de contr√¥le trouv√©e. Utilisez les donn√©es de test ou commencez un parcours dans l\'application.</div>';

                // Ajouter les donn√©es de test √† checkIdData
                checkIdData['test-checkin-001'] = createTestData('checkin');
                checkIdData['test-checkout-001'] = createTestData('checkout');
                return;
            }

            // Ajouter les CheckIDs au s√©lecteur avec d√©tails enrichis
            checkIds.forEach(checkId => {
                const session = sessions[checkId];
                const option = document.createElement('option');
                option.value = checkId;

                // üéØ NOUVEAU: Utiliser les champs de CheckSession depuis IndexedDB
                const flowType = session.flowType || 'inconnu';
                const status = session.status || 'active';
                const isCompleted = session.isFlowCompleted ? '‚úÖ' : '‚è≥';
                const createdDate = session.createdAt ? new Date(session.createdAt).toLocaleDateString() : '';

                // Construire le texte du dropdown
                let displayText = `${checkId} | ${flowType.toUpperCase()} ${isCompleted} | ${status} | ${createdDate}`;

                // Limiter la longueur pour √©viter un dropdown trop large
                if (displayText.length > 80) {
                    displayText = displayText.substring(0, 77) + '...';
                }

                option.textContent = displayText;
                select.appendChild(option);
            });

            // Stocker les donn√©es
            checkIdData = sessions;

            showAlert(`${checkIds.length} CheckID(s) trouv√©(s) dans IndexedDB`, 'success');
        }
        
        function loadCheckIdData() {
            const select = document.getElementById('checkIdSelect');
            const checkId = select.value;
            
            if (!checkId || !checkIdData[checkId]) {
                document.getElementById('selectedCheckIdInfo').style.display = 'none';
                document.getElementById('checkIdDataContent').innerHTML = '';
                selectedCheckId = null;
                return;
            }
            
            selectedCheckId = checkId;
            const sessionData = checkIdData[checkId];
            
            // Afficher les infos du CheckID
            displayCheckIdInfo(checkId, sessionData);
            
            // Afficher les donn√©es d√©taill√©es
            displayCheckIdDetails(checkId, sessionData);
            
            // Afficher les sections webhook et configuration
            document.getElementById('webhookConfigSection').style.display = 'block';
            document.getElementById('webhookSection').style.display = 'block';
            document.getElementById('selectedCheckIdDisplay').textContent = checkId;
            
            // D√©tecter et afficher l'√©tat de la session
            const sessionStateInfo = determineSessionState(sessionData);
            document.getElementById('sessionStateDisplay').textContent = sessionStateInfo.state;
            document.getElementById('sessionStateReason').textContent = sessionStateInfo.reason;
            
            // Colorer l'√©tat selon le type
            const stateElement = document.getElementById('sessionStateDisplay');
            if (sessionStateInfo.state === 'checkout') {
                stateElement.style.color = '#dc3545'; // Rouge pour checkout
                stateElement.style.fontWeight = 'bold';
            } else {
                stateElement.style.color = '#28a745'; // Vert pour checkin
                stateElement.style.fontWeight = 'bold';
            }
        }
        
        function displayCheckIdInfo(checkId, sessionData) {
            const infoSection = document.getElementById('selectedCheckIdInfo');
            const titleElement = document.getElementById('checkIdTitle');
            const statsElement = document.getElementById('checkIdStats');
            
            titleElement.textContent = `CheckID: ${checkId}`;
            
            // G√©n√©rer les statistiques
            let statsHtml = '';
            
            // Logement
            if (sessionData.logement_id) {
                statsHtml += `
                    <div class="stat-card">
                        <div class="stat-number">üè†</div>
                        <div class="stat-label">${sessionData.logement_id}</div>
                    </div>
                `;
            }
            
            // Date
            if (sessionData.timestamp) {
                const date = new Date(sessionData.timestamp);
                statsHtml += `
                    <div class="stat-card">
                        <div class="stat-number">üìÖ</div>
                        <div class="stat-label">${date.toLocaleDateString()}</div>
                    </div>
                `;
            }
            
            // Nombre de cl√©s
            const keyCount = Object.keys(sessionData).length;
            statsHtml += `
                <div class="stat-card">
                    <div class="stat-number">${keyCount}</div>
                    <div class="stat-label">Propri√©t√©s</div>
                </div>
            `;
            
            // Taille des donn√©es
            const dataSize = Math.round(JSON.stringify(sessionData).length / 1024);
            statsHtml += `
                <div class="stat-card">
                    <div class="stat-number">${dataSize} KB</div>
                    <div class="stat-label">Taille</div>
                </div>
            `;
            
            statsElement.innerHTML = statsHtml;
            infoSection.style.display = 'block';
        }
        
        function displayCheckIdDetails(checkId, sessionData) {
            const container = document.getElementById('checkIdDataContent');
            
            // Analyser et organiser les donn√©es
            const organizedData = organizeCheckIdData(sessionData);
            
            let html = '';
            
            // Vue d'ensemble
            html += `
                <div class="data-section">
                    <div class="data-section-header" onclick="toggleSection('overview')">
                        <div class="data-section-title">üìä Vue d'ensemble</div>
                        <div class="data-section-badge">R√©sum√©</div>
                    </div>
                    <div class="data-section-content" id="overview">
                        <div class="data-overview">
            `;
            
            Object.entries(organizedData.overview).forEach(([key, value]) => {
                html += `
                    <div class="overview-item">
                        <div class="overview-label">${key}</div>
                        <div class="overview-value">${value}</div>
                    </div>
                `;
            });
            
            html += '</div></div></div>';
            
            // Donn√©es d√©taill√©es par cat√©gorie
            Object.entries(organizedData.sections).forEach(([sectionName, sectionData]) => {
                const sectionId = `section-${sectionName.replace(/\s+/g, '-').toLowerCase()}`;
                
                html += `
                    <div class="data-section">
                        <div class="data-section-header" onclick="toggleSection('${sectionId}')">
                            <div class="data-section-title">${sectionData.icon} ${sectionName}</div>
                            <div class="data-section-badge">${sectionData.count} √©l√©ment(s)</div>
                        </div>
                        <div class="data-section-content" id="${sectionId}">
                            ${createEnhancedJsonViewer(sectionData.data)}
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function organizeCheckIdData(sessionData) {
            const overview = {
                'Type de session': sessionData.sessionType || 'Contr√¥le',
                'Logement ID': sessionData.logement_id || 'Non d√©fini',
                'Utilisateur': sessionData.user_id || sessionData.userId || 'Non d√©fini',
                'Statut': sessionData.status || sessionData.state || 'En cours',
            };
            
            const sections = {};
            
            // Organiser par cat√©gories
            Object.entries(sessionData).forEach(([key, value]) => {
                let category = 'Autres donn√©es';
                let icon = 'üìÑ';
                
                if (key.includes('piece') || key.includes('room')) {
                    category = 'Pi√®ces & Espaces';
                    icon = 'üè†';
                } else if (key.includes('photo') || key.includes('image')) {
                    category = 'Photos & M√©dias';
                    icon = 'üì∏';
                } else if (key.includes('user') || key.includes('operator')) {
                    category = 'Utilisateurs';
                    icon = 'üë§';
                } else if (key.includes('task') || key.includes('step') || key.includes('progress')) {
                    category = 'T√¢ches & Progression';
                    icon = '‚úÖ';
                } else if (key.includes('time') || key.includes('date') || key === 'timestamp') {
                    category = 'Horodatage';
                    icon = '‚è∞';
                } else if (key.includes('config') || key.includes('setting')) {
                    category = 'Configuration';
                    icon = '‚öôÔ∏è';
                }
                
                if (!sections[category]) {
                    sections[category] = {
                        icon: icon,
                        data: {},
                        count: 0
                    };
                }
                
                sections[category].data[key] = value;
                sections[category].count++;
            });
            
            return { overview, sections };
        }
        
        function createEnhancedJsonViewer(data) {
            return `<div class="json-enhanced">${formatJsonWithColors(data, 0)}</div>`;
        }
        
        function formatJsonWithColors(obj, depth = 0) {
            const indent = '  '.repeat(depth);
            
            if (obj === null) {
                return '<span class="json-null">null</span>';
            }
            
            if (typeof obj === 'string') {
                // Tronquer les donn√©es base64 pour la lisibilit√©
                let displayString = obj;
                if (obj.startsWith('data:image/') && obj.includes('base64,')) {
                    const base64Start = obj.indexOf('base64,') + 7;
                    const truncated = obj.substring(0, base64Start + 50) + '...[BASE64 TRUNCATED ' + (obj.length - base64Start - 50) + ' chars]';
                    displayString = truncated;
                } else if (obj.startsWith('/9j/4') || obj.match(/^[A-Za-z0-9+/]{100,}={0,2}$/)) {
                    // D√©tection de base64 pur (commence souvent par /9j/4 pour JPEG ou pattern base64)
                    const truncated = obj.substring(0, 50) + '...[BASE64 TRUNCATED ' + (obj.length - 50) + ' chars]';
                    displayString = truncated;
                }
                return `<span class="json-string">"${escapeHtml(displayString)}"</span>`;
            }
            
            if (typeof obj === 'number') {
                return `<span class="json-number">${obj}</span>`;
            }
            
            if (typeof obj === 'boolean') {
                return `<span class="json-boolean">${obj}</span>`;
            }
            
            if (Array.isArray(obj)) {
                if (obj.length === 0) {
                    return '[]';
                }
                
                const toggleId = `toggle-${Math.random().toString(36).substr(2, 9)}`;
                let result = `<span class="json-toggle" onclick="toggleJsonSection('${toggleId}')">‚ñº</span>[\n`;
                result += `<div id="${toggleId}">`;
                
                obj.forEach((item, index) => {
                    result += `${indent}  ${formatJsonWithColors(item, depth + 1)}`;
                    if (index < obj.length - 1) result += ',';
                    result += '\n';
                });
                
                result += `</div>${indent}]`;
                return result;
            }
            
            if (typeof obj === 'object') {
                const keys = Object.keys(obj);
                if (keys.length === 0) {
                    return '{}';
                }
                
                const toggleId = `toggle-${Math.random().toString(36).substr(2, 9)}`;
                let result = `<span class="json-toggle" onclick="toggleJsonSection('${toggleId}')">‚ñº</span>{\n`;
                result += `<div id="${toggleId}">`;
                
                keys.forEach((key, index) => {
                    result += `${indent}  <span class="json-key">"${escapeHtml(key)}"</span>: ${formatJsonWithColors(obj[key], depth + 1)}`;
                    if (index < keys.length - 1) result += ',';
                    result += '\n';
                });
                
                result += `</div>${indent}}`;
                return result;
            }
            
            return String(obj);
        }
        
        function escapeHtml(text) {
            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            
            return text.replace(/[&<>"']/g, function(m) { return map[m]; });
        }
        
        function toggleJsonSection(toggleId) {
            const element = document.getElementById(toggleId);
            const toggle = element.previousElementSibling;
            
            if (element.classList.contains('json-collapsed')) {
                element.classList.remove('json-collapsed');
                toggle.textContent = '‚ñº';
            } else {
                element.classList.add('json-collapsed');
                toggle.textContent = '‚ñ∂';
            }
        }
        
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.style.display = section.style.display === 'none' ? 'block' : 'none';
            }
        }
        
        // === WEBHOOK SENDER ===
        let checkinDataGenerated = null;
        let checkoutDataGenerated = null;
        
        function debugPhotoExtraction() {
            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('S√©lectionnez un CheckID d\'abord', 'error');
                return;
            }
            
            console.log('üîç DEBUG PHOTOS - D√©but de l\'analyse');
            
            const sessionData = checkIdData[selectedCheckId];
            const allPhotos = getAllPhotosFromStorage();
            
            const debugInfo = {
                selectedCheckId: selectedCheckId,
                sessionDataKeys: Object.keys(sessionData),
                totalPhotosInStorage: allPhotos.length,
                photosDetails: allPhotos.map(photo => ({
                    storageKey: photo.storageKey,
                    photoId: photo.photoId,
                    pieceId: photo.pieceId,
                    taskId: photo.taskId,
                    hasUrl: !!photo.url,
                    hasDataUrl: !!photo.dataUrl,
                    timestamp: photo.timestamp
                })),
                photosGroupedByPieceId: {},
                sessionDataAnalysis: {}
            };
            
            // Grouper par pieceId
            allPhotos.forEach(photo => {
                const pieceId = photo.pieceId || 'no_piece_id';
                if (!debugInfo.photosGroupedByPieceId[pieceId]) {
                    debugInfo.photosGroupedByPieceId[pieceId] = [];
                }
                debugInfo.photosGroupedByPieceId[pieceId].push(photo.photoId || 'no_photo_id');
            });
            
            // Analyser les donn√©es de session
            Object.keys(sessionData).forEach(key => {
                if (key.includes('piece') || key.includes('room') || key.includes('photo') || key.includes('image')) {
                    debugInfo.sessionDataAnalysis[key] = typeof sessionData[key];
                }
            });
            
            // Afficher dans l'interface
            document.getElementById('debugSection').style.display = 'block';
            document.getElementById('debugContent').innerHTML = createEnhancedJsonViewer(debugInfo);
            
            console.log('üîç DEBUG PHOTOS - Analyse compl√®te:', debugInfo);
            showAlert(`${allPhotos.length} photos analys√©es - Voir section Debug`, 'info');
        }
        
        /**
         * üéØ HELPER: Tronquer les base64 dans un objet pour l'affichage
         */
        function truncateBase64InObject(obj, maxLength = 50) {
            if (obj === null || obj === undefined) return obj;

            if (typeof obj === 'string') {
                // Si c'est une cha√Æne base64 (commence par data:image ou tr√®s longue)
                if (obj.startsWith('data:image') || obj.length > 200) {
                    return obj.substring(0, maxLength) + '...[TRONQU√â ' + obj.length + ' caract√®res]';
                }
                return obj;
            }

            if (Array.isArray(obj)) {
                return obj.map(item => truncateBase64InObject(item, maxLength));
            }

            if (typeof obj === 'object') {
                const result = {};
                for (const key in obj) {
                    if (key.includes('base64') || key.includes('Base64')) {
                        result[key] = truncateBase64InObject(obj[key], maxLength);
                    } else {
                        result[key] = truncateBase64InObject(obj[key], maxLength);
                    }
                }
                return result;
            }

            return obj;
        }

        /**
         * üéØ G√âN√âRER LE WEBHOOK UNIFI√â (pour pr√©visualisation)
         */
        function generateUnifiedData() {
            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('Aucun CheckID s√©lectionn√©', 'error');
                return;
            }

            const sessionData = checkIdData[selectedCheckId];

            console.log('üéØ G√©n√©ration Webhook UNIFI√â (CHECKIN + CHECKOUT)');

            // G√©n√©rer les donn√©es unifi√©es
            const unifiedData = generateWebhookData(sessionData, 'unified');

            // Tronquer les base64 pour l'affichage
            const unifiedDataTruncated = truncateBase64InObject(unifiedData, 50);

            // Afficher dans l'interface
            document.getElementById('unifiedDataPreview').innerHTML = createEnhancedJsonViewer(unifiedDataTruncated);

            showAlert('‚úÖ Donn√©es Webhook UNIFI√â g√©n√©r√©es (base64 tronqu√©s pour affichage)', 'success');
            console.log('üì¶ Webhook UNIFI√â g√©n√©r√©:', unifiedData);
            console.log('üì¶ Webhook UNIFI√â (tronqu√© pour affichage):', unifiedDataTruncated);
        }

        function generateCheckinData() {
            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('Aucun CheckID s√©lectionn√©', 'error');
                return;
            }

            const sessionData = checkIdData[selectedCheckId];

            // üéØ NOUVELLE STRUCTURE: Utiliser la fonction structur√©e par √©tapes
            console.log('üèóÔ∏è G√©n√©ration CheckIn avec nouvelle structure par √©tapes');

            // Extraire les donn√©es utilisateur et parcours
            const userVerificationData = extractUserVerificationData(sessionData);
            const parcoursLogementInfo = extractParcoursLogementInfo(sessionData);

            // üéØ NOUVEAU: Extraire les √©tapes organis√©es par pi√®ce
            const etapesParPiece = extractEtapesStructurees(sessionData, 'checkin');

            // D√©terminer l'√©tat de la session (pour compatibilit√©)
            const sessionStateInfo = determineSessionState(sessionData);
            console.log('üìç √âtat de la session d√©tect√©:', sessionStateInfo);

            // üéØ NOUVELLE STRUCTURE SP√âCIFI√âE: G√©n√©rer le JSON selon le format demand√©
            const checkinData = generateWebhookData(sessionData, 'checkin');

            checkinDataGenerated = checkinData;

            // Afficher dans l'interface
            document.getElementById('checkinDataPreview').innerHTML = createEnhancedJsonViewer(checkinData);
            document.getElementById('sendCheckinBtn').disabled = false;

            showAlert('‚úÖ Donn√©es CheckIn g√©n√©r√©es (structure par √©tapes)', 'success');
            console.log('üì¶ CheckIn g√©n√©r√© (nouvelle structure):', checkinData);
        }

        // === G√âN√âRATION CHECKOUT DATA ===
        
        function generateCheckoutData() {
            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('Aucun CheckID s√©lectionn√©', 'error');
                return;
            }
            
            const sessionData = checkIdData[selectedCheckId];
            
            // üéØ NOUVELLE STRUCTURE: Utiliser la fonction structur√©e par √©tapes
            console.log('üèóÔ∏è G√©n√©ration CheckOut avec nouvelle structure par √©tapes');
            
            // Extraire les donn√©es utilisateur et parcours
            const userVerificationData = extractUserVerificationData(sessionData);
            const parcoursLogementInfo = extractParcoursLogementInfo(sessionData);
            
            // üéØ NOUVEAU: Extraire les √©tapes organis√©es par pi√®ce pour checkout
            const etapesParPiece = extractEtapesStructurees(sessionData, 'checkout');
            
            // D√©terminer l'√©tat de la session (pour compatibilit√©)
            const sessionStateInfo = determineSessionState(sessionData);
            console.log('üìç √âtat de la session d√©tect√©:', sessionStateInfo);
            
            // üéØ NOUVELLE STRUCTURE SP√âCIFI√âE: G√©n√©rer le JSON selon le format demand√©
            const checkoutData = generateWebhookData(sessionData, 'checkout');
            
            checkoutDataGenerated = checkoutData;
            
            // Afficher dans l'interface
            document.getElementById('checkoutDataPreview').innerHTML = createEnhancedJsonViewer(checkoutData);
            document.getElementById('sendCheckoutBtn').disabled = false;
            
            showAlert('‚úÖ Donn√©es CheckOut g√©n√©r√©es (structure par √©tapes)', 'success');
            console.log('üì¶ CheckOut g√©n√©r√© (nouvelle structure):', checkoutData);
        }

        // === G√âN√âRATION CHECKOUT DONN√âE (FALLBACK POUR COMPATIBILIT√â) ===
        
        function generateCheckinDataLegacy() {
            // Code de fallback pour l'ancienne structure (non utilis√©)
            console.log('‚ö†Ô∏è Fonction legacy non impl√©ment√©e - utiliser generateCheckinData() √† la place');
            return null;
        }
        
        function extractPiecesProgressCheckout(sessionData) {
            const pieces = [];
            
            console.log('üßπ EXTRACTION CHECKOUT - Session data keys:', Object.keys(sessionData));
            
            // Note: Cette fonction a √©t√© simplifi√©e pour corriger les erreurs de syntaxe
            console.log(`üìä EXTRACTION CHECKOUT R√âSULTAT: ${pieces.length} pi√®ces`);
            return pieces;
        }
        
        function generateCheckoutDataLegacy() {
            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('Aucun CheckID s√©lectionn√©', 'error');
                return;
            }
            
            console.log('üßπ === G√âN√âRATION CHECKOUT (LEGACY) ===');
            const sessionData = checkIdData[selectedCheckId];
            
            // G√©n√©rer un ID unique pour ce webhook
            const webhookId = generateUniqueWebhookId(selectedCheckId);
            
            // Extraire les informations utilisateur compl√®tes
            const userVerificationData = extractUserVerificationData(sessionData);
            
            // Extraire les IDs de parcours et logement
            const parcoursLogementInfo = extractParcoursLogementInfo(sessionData);
            
            // Legacy function - simplified to avoid syntax errors
            return null;
        }
        
        // === AUTRE FONCTION CHECKOUT LEGACY (√Ä SUPPRIMER PLUS TARD) ===
        
        function anotherLegacyFunction() {
            // Cette section contient du code legacy qui sera nettoy√© plus tard
            console.log('‚ö†Ô∏è Fonction legacy non impl√©ment√©e');
            return [];
        } // FIN anotherLegacyFunction()
        
        function generateCheckinDataAdvanced() {
            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('Aucun CheckID s√©lectionn√©', 'error');
                return;
            }
            
            const sessionData = checkIdData[selectedCheckId];
            
            // D√©terminer l'√©tat de la session
            const sessionStateInfo = determineSessionState(sessionData);
            console.log('üìç √âtat de la session d√©tect√©:', sessionStateInfo);
            
            // Analyser localStorage pour r√©cup√©rer les photos upload√©es
            const allPhotosFromStorage = getAllPhotosFromStorage();
            console.log('üì∏ Photos trouv√©es dans localStorage:', allPhotosFromStorage.length);
            
            // Extraire les pi√®ces analys√©es selon la nouvelle logique
            const pieces_analysees = [];
            
            // Regrouper les photos par pi√®ces
            const piecesByPhotoIds = {};
            allPhotosFromStorage.forEach(photo => {
                const pieceId = extractPieceIdFromPhoto(photo);
                if (pieceId && pieceId !== 'unknown_piece') {
                    if (!piecesByPhotoIds[pieceId]) {
                        piecesByPhotoIds[pieceId] = [];
                    }
                    piecesByPhotoIds[pieceId].push(photo);
                }
            });
            
            Object.entries(piecesByPhotoIds).forEach(([pieceId, photos]) => {
                const pieceData = {
                    piece: {
                        id: pieceId,
                        nom: getPieceName(pieceId),
                        etat_utilisateur: 'non_d√©fini',
                        statut_validation: 'en_attente'
                    },
                    commentaire: null,
                    photos: photos.map(photo => ({
                        url: photo.url,
                        timestamp: photo.timestamp || photo.metadata?.takenAt,
                        type: photo.metadata?.type || 'etat_initial'
                    })),
                    timestamp_validation: new Date().toISOString()
                };
                
                pieces_analysees.push(pieceData);
            });
            
            // G√©n√©rer un ID unique pour ce webhook (bas√© sur le format CheckID)
            const webhookId = generateUniqueWebhookId(selectedCheckId);
            
            // Extraire les informations utilisateur compl√®tes
            const userVerificationData = extractUserVerificationData(sessionData);
            
            // Extraire les IDs de parcours et logement
            const parcoursLogementInfo = extractParcoursLogementInfo(sessionData);
            
            // G√©n√©rer les donn√©es CheckIn avec le nouveau format sp√©cifi√©
            checkinDataGenerated = generateWebhookData(sessionData, 'checkin');
            
            // Afficher dans l'interface
            document.getElementById('checkinDataPreview').innerHTML = createEnhancedJsonViewer(checkinDataGenerated);
            document.getElementById('sendCheckinBtn').disabled = false;
            document.getElementById('generatedWebhookIdDisplay').textContent = checkinDataGenerated.parcours?.id || 'unknown';
            
            const summary = `CheckIn g√©n√©r√©: ${checkinDataGenerated.pieces.length} pi√®ces analys√©es (ID: ${checkinDataGenerated.parcours.id})`;
            showAlert(summary, 'success');
            
            console.log('üì• CHECKIN DATA G√âN√âR√â:', checkinDataGenerated);
        }
        
        /* FONCTION DUPLIQU√âE COMMENT√âE - UTILISER LA PREMI√àRE G√âN√âRATION √Ä LA LIGNE 1661
        function generateCheckoutDataDUPLICATE_TO_REMOVE() { // FONCTION DUPLIQU√âE - √Ä SUPPRIMER
            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('Aucun CheckID s√©lectionn√©', 'error');
                return;
            }
            
            const sessionData = checkIdData[selectedCheckId];
            
            // D√©terminer l'√©tat de la session
            const sessionStateInfo = determineSessionState(sessionData);
            console.log('üìç √âtat de la session d√©tect√©:', sessionStateInfo);
            
            // V√©rifier si on est vraiment en phase checkout
            if (sessionStateInfo.state !== 'checkout') {
                showAlert('‚ö†Ô∏è Session pas encore en phase checkout - donn√©es vides g√©n√©r√©es', 'warning');
                checkoutDataGenerated = {
                    checkID: selectedCheckId,
                    checkType: "checkout",
                    logement_id: sessionData.logement_id || null,
                    user_id: sessionData.user_id || sessionData.userId || null,
                    timestamp: new Date().toISOString(),
                    session_info: {
                        type: getSessionType(sessionData),
                        state: sessionStateInfo.state,
                        reason: sessionStateInfo.reason,
                        progression_globale: sessionData.progress?.progressPercentage || 0
                    },
                    statistiques_menage: {
                        pieces_totales: 0,
                        taches_completees_total: 0,
                        photos_prises_total: 0,
                        interactions_totales: 0
                    },
                    pieces_menage: []
                };
                
                document.getElementById('checkoutDataPreview').innerHTML = createEnhancedJsonViewer(checkoutDataGenerated);
                document.getElementById('sendCheckoutBtn').disabled = false;
                return;
            }
            
            // Extraire les pi√®ces avec la nouvelle logique checkout
            const piecesCheckout = extractPiecesProgressCheckout(sessionData);
            console.log('üè† Pi√®ces checkout extraites:', piecesCheckout);
            
            // G√©n√©rer un ID unique pour ce webhook (bas√© sur le format CheckID)
            const webhookId = generateUniqueWebhookId(selectedCheckId);
            
            // Extraire les informations utilisateur compl√®tes
            const userVerificationData = extractUserVerificationData(sessionData);
            
            // Extraire les IDs de parcours et logement
            const parcoursLogementInfo = extractParcoursLogementInfo(sessionData);
            
            // G√©n√©rer les donn√©es CheckOut avec le nouveau format
            checkoutDataGenerated = {
                checkID: webhookId,
                checkType: "checkout",
                parcours_id: parcoursLogementInfo.parcours_id,
                parcours_name: parcoursLogementInfo.parcours_name,
                logement_id: parcoursLogementInfo.logement_id,
                logement_name: parcoursLogementInfo.logement_name,
                user_id: sessionData.user_id || sessionData.userId || null,
                user_firstname: userVerificationData.user_info?.firstName || null,
                user_lastname: userVerificationData.user_info?.lastName || null,
                user_phone: userVerificationData.user_info?.phone || null,
                user_type: userVerificationData.user_info?.type || null,
                user_type_label: userVerificationData.user_info?.type_label || null,
                timestamp: new Date().toISOString(),
                session_info: {
                    type: getSessionType(sessionData),
                    state: sessionStateInfo.state,
                    reason: sessionStateInfo.reason,
                    progression_globale: sessionData.progress?.progressPercentage || 0
                },
                user_verification: userVerificationData,
                statistiques_menage: {
                    pieces_totales: piecesCheckout.length,
                    taches_completees_total: sessionData.progress?.completedTaskIds?.length || 0,
                    photos_prises_total: sessionData.progress?.statistics?.totalPhotos || 0,
                    interactions_totales: Object.values(sessionData.progress?.pieceStates || {})
                        .reduce((sum, state) => sum + (state.totalInteractions || 0), 0)
                },
                pieces_menage: piecesCheckout,
                etapes_details: extractEtapesDetails(sessionData, piecesCheckout)
            };
            
            // Afficher dans l'interface
            document.getElementById('checkoutDataPreview').innerHTML = createEnhancedJsonViewer(checkoutDataGenerated);
            document.getElementById('sendCheckoutBtn').disabled = false;
            document.getElementById('generatedWebhookIdDisplay').textContent = webhookId;
            
            const totalTasks = checkoutDataGenerated.statistiques_menage.taches_completees_total;
            const totalPieces = checkoutDataGenerated.statistiques_menage.pieces_totales;
            const summary = `CheckOut g√©n√©r√©: ${totalPieces} pi√®ces, ${totalTasks} t√¢ches (ID: ${webhookId.substring(0, 20)}...)`;
            showAlert(summary, 'success');
            
            console.log('üì§ CHECKOUT DATA G√âN√âR√â:', checkoutDataGenerated);
        } // FIN FONCTION DUPLIQU√âE - √Ä SUPPRIMER
        */
        
        function extractPiecesProgress(sessionData, checkType) {
            const pieces = [];
            
            console.log('üîç EXTRACTION PIECES - Session data keys:', Object.keys(sessionData));
            console.log('üîç EXTRACTION PIECES - CheckType:', checkType);
            
            // D√©terminer l'√©tat actuel de la session
            const sessionStateInfo = determineSessionState(sessionData);
            console.log('üìç √âtat de la session d√©tect√©:', sessionStateInfo);
            
            // Si on demande des donn√©es checkout mais qu'on est encore en checkin, retourner des donn√©es vides
            if (checkType === 'checkout' && sessionStateInfo.state !== 'checkout') {
                console.log('‚ö†Ô∏è Donn√©es checkout demand√©es mais session encore en checkin - retour donn√©es vides');
                return [];
            }
            
            // üéØ NOUVELLE LOGIQUE: Extraire les √©tats des pi√®ces depuis buttonClicks
            const roomStates = extractRoomStatesFromSession(sessionData);
            console.log('üè† √âtats des pi√®ces extraits:', roomStates);
            
            // Analyser localStorage pour r√©cup√©rer les photos upload√©es
            const allPhotosFromStorage = getAllPhotosFromStorage();
            console.log('üì∏ Photos trouv√©es dans localStorage:', allPhotosFromStorage.length);
            
            // Cr√©er les pi√®ces bas√©es sur les vrais √©tats utilisateur
            Object.entries(roomStates).forEach(([pieceId, roomData]) => {
                const piecePhotos = allPhotosFromStorage.filter(photo => 
                    photo.pieceId === pieceId || 
                    photo.metadata?.pieceId === pieceId ||
                    photo.piece_id === pieceId ||
                    photo.storageKey.includes(pieceId)
                );
                
                const pieceData = {
                    piece_id: pieceId,
                    nom: getPieceName(pieceId),
                    etat_utilisateur: roomData.state, // "correct" ou "deplorable"
                    commentaire: roomData.comment || null,
                    photos: piecePhotos.map(photo => ({
                        url: photo.url,
                        dataUrl: photo.dataUrl,
                        timestamp: photo.timestamp || photo.metadata?.takenAt,
                        type: photo.metadata?.type || 'etat_initial'
                    })),
                    timestamp: roomData.timestamp || new Date().toISOString(),
                    statut_validation: roomData.state === 'correct' ? 'valid√©' : 'probl√®me_d√©tect√©'
                };
                
                console.log(`üè† Pi√®ce ${pieceId}: √©tat="${roomData.state}", photos=${piecePhotos.length}, commentaire=${!!roomData.comment}`);
                pieces.push(pieceData);
            });
            
            // üîç FALLBACK: Si aucun √©tat trouv√©, essayer de d√©duire depuis les photos
            if (pieces.length === 0) {
                console.log('‚ö†Ô∏è Aucun √©tat de pi√®ce trouv√©, analyse depuis les photos...');
                
                const piecesByPhotoIds = {};
                allPhotosFromStorage.forEach(photo => {
                    const pieceId = extractPieceIdFromPhoto(photo);
                    if (pieceId && pieceId !== 'unknown_piece') {
                        if (!piecesByPhotoIds[pieceId]) {
                            piecesByPhotoIds[pieceId] = [];
                        }
                        piecesByPhotoIds[pieceId].push(photo);
                    }
                });
                
                Object.entries(piecesByPhotoIds).forEach(([pieceId, photos]) => {
                    const pieceData = {
                        piece_id: pieceId,
                        nom: getPieceName(pieceId),
                        etat_utilisateur: 'non_d√©fini',
                        commentaire: null,
                        photos: photos.map(photo => ({
                            url: photo.url,
                            dataUrl: photo.dataUrl,
                            timestamp: photo.timestamp || photo.metadata?.takenAt,
                            type: photo.metadata?.type || 'etat_initial'
                        })),
                        timestamp: new Date().toISOString(),
                        statut_validation: 'en_attente',
                        source: 'photos_seulement'
                    };
                    
                    pieces.push(pieceData);
                });
            }
            
            console.log(`üìä R√âSULTAT: ${pieces.length} pi√®ces extraites`);
            return pieces;
        }
        
        function extractPiecesProgressCheckout(sessionData) {
            const pieces = [];
            
            console.log('üßπ EXTRACTION CHECKOUT - Session data keys:', Object.keys(sessionData));
            
            // Analyser les donn√©es sp√©cifiques au checkout (m√©nage)
            const buttonClicks = sessionData.progress?.interactions?.buttonClicks || {};
            const photosTaken = sessionData.progress?.photosTaken || {};
            const pieceStates = sessionData.progress?.pieceStates || {};
            const completedTaskIds = sessionData.progress?.completedTaskIds || [];
            const statistics = sessionData.progress?.statistics || {};
            
            console.log('üè† Pi√®ces d√©tect√©es dans pieceStates:', Object.keys(pieceStates));
            console.log('‚úÖ T√¢ches compl√©t√©es:', completedTaskIds.length, completedTaskIds);
            console.log('üì∏ Photos prises:', Object.keys(photosTaken).length);
            
            // Grouper les donn√©es par pi√®ce
            const pieceData = {};
            
            // 1. Analyser les buttonClicks pour extraire les t√¢ches par pi√®ce
            Object.entries(buttonClicks).forEach(([key, clickArray]) => {
                const clicks = Array.isArray(clickArray) ? clickArray : [clickArray];
                
                clicks.forEach(click => {
                    if (click.metadata?.page === 'checkout' && click.pieceId !== 'undefined') {
                        const pieceId = click.pieceId;
                        
                        if (!pieceData[pieceId]) {
                            pieceData[pieceId] = {
                                piece_id: pieceId,
                                nom: click.metadata?.pieceName || getPieceName(pieceId),
                                taches_menage: [],
                                photos_checkout: [],
                                statut_menage: 'en_cours'
                            };
                        }
                        
                        // Analyser les t√¢ches
                        if (click.metadata?.taskType === 'checkbox' && click.actionType === 'task_complete') {
                            const tache = {
                                id: click.buttonId,
                                nom: formatTaskNameFromButtonId(click.buttonId),
                                type: click.metadata.taskType,
                                statut: click.metadata.completed ? 'completed' : 'pending',
                                timestamp: click.timestamp
                            };
                            
                            // √âviter les doublons
                            if (!pieceData[pieceId].taches_menage.find(t => t.id === tache.id)) {
                                pieceData[pieceId].taches_menage.push(tache);
                            }
                        }
                        
                        // Analyser les photos de r√©f√©rence
                        if (click.metadata?.taskType === 'reference_photos' && click.actionType === 'task_complete') {
                            const photoRef = {
                                type: 'reference_photos',
                                timestamp: click.timestamp,
                                statut: 'completed'
                            };
                            
                            pieceData[pieceId].photos_reference = photoRef;
                        }
                    }
                });
            });
            
            // 2. Associer les photos prises aux pi√®ces
            Object.entries(photosTaken).forEach(([photoKey, photoArray]) => {
                if (photoKey === 'undefined') return;
                
                const photos = Array.isArray(photoArray) ? photoArray : [photoArray];
                photos.forEach(photo => {
                    if (photo.pieceId && photo.pieceId !== 'undefined' && photo.metadata?.page === 'checkout') {
                        const pieceId = photo.pieceId;
                        
                        if (pieceData[pieceId]) {
                            const photoData = {
                                photo_id: photo.photoId,
                                url: photo.metadata?.url || photo.url,
                                timestamp: photo.timestamp,
                                task_id: photo.metadata?.taskId || photo.taskId,
                                etape_id: photo.metadata?.etapeId,
                                type: photo.metadata?.taskId?.includes('reference-photos') ? 'reference' : 'task_photo',
                                validated: photo.validated || false
                            };
                            
                            pieceData[pieceId].photos_checkout.push(photoData);
                        }
                    }
                });
            });
            
            // 3. Enrichir avec les statistiques des pieceStates
            Object.entries(pieceStates).forEach(([pieceId, state]) => {
                if (pieceId !== 'undefined' && pieceData[pieceId]) {
                    pieceData[pieceId].interactions_total = state.totalInteractions || 0;
                    pieceData[pieceId].photos_count = state.photosCount || 0;
                    pieceData[pieceId].checkboxes_count = state.checkboxesCount || 0;
                    pieceData[pieceId].completion_percentage = state.completionPercentage || 0;
                    pieceData[pieceId].statut_menage = determineCheckoutStatus(pieceId, completedTaskIds, pieceData[pieceId].taches_menage);
                }
            });
            
            // 4. Convertir en array et calculer les r√©sum√©s
            Object.values(pieceData).forEach(piece => {
                const tachesCompleted = piece.taches_menage.filter(t => t.statut === 'completed').length;
                const tachesTotal = piece.taches_menage.length;
                
                const pieceResult = {
                    piece: {
                        id: piece.piece_id,
                        nom: piece.nom,
                        statut_menage: piece.statut_menage,
                        completion_percentage: piece.completion_percentage || 0
                    },
                    taches_menage: piece.taches_menage.map(tache => ({
                        nom: tache.nom,
                        type: tache.type,
                        statut: tache.statut,
                        timestamp: tache.timestamp
                    })),
                    photos_checkout: piece.photos_checkout,
                    photos_reference: piece.photos_reference || null,
                    resume: {
                        taches_completees: tachesCompleted,
                        taches_total: tachesTotal,
                        progression_taches: tachesTotal > 0 ? Math.round((tachesCompleted / tachesTotal) * 100) : 0,
                        photos_prises: piece.photos_checkout.length,
                        interactions_total: piece.interactions_total || 0
                    }
                };
                
                console.log(`üßπ Pi√®ce ${piece.nom}: ${tachesCompleted}/${tachesTotal} t√¢ches, ${piece.photos_checkout.length} photos`);
                pieces.push(pieceResult);
            });
            
            console.log(`üìä CHECKOUT R√âSULTAT: ${pieces.length} pi√®ces avec t√¢ches de m√©nage`);
            return pieces;
        }
        
        function formatTaskNameFromButtonId(buttonId) {
            // Convertir les IDs de t√¢ches en noms lisibles fran√ßais
            const taskMappings = {
                '-vider-le-lave-vaisselle': 'Vider le lave-vaisselle',
                '-nettoyer-la-machine-caf-et-la': 'Nettoyer la machine √† caf√©',
                '-nettoyer-le-four': 'Nettoyer le four',
                '-vider-la-poubelle-et-ajouter': 'Vider la poubelle et changer le sac',
                '-vider-et-nettoyer-le-frigo': 'Vider et nettoyer le frigo',
                '-nettoyer-lvier-le-siphon': 'Nettoyer l\'√©vier et le siphon',
                '-vrifier-les-produits-mnagers': 'V√©rifier les produits m√©nagers',
                '-toilettes': 'Nettoyer les toilettes',
                'reference-photos': 'Photos de r√©f√©rence'
            };
            
            return taskMappings[buttonId] || buttonId.replace(/^-/, '').replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }
        
        function determineCheckoutStatus(pieceId, completedTaskIds, tachesMenage) {
            // Compter les t√¢ches compl√©t√©es pour cette pi√®ce
            const tachesCompletedCount = tachesMenage.filter(t => t.statut === 'completed').length;
            const tachesTotalCount = tachesMenage.length;
            
            if (tachesTotalCount === 0) return 'non_commence';
            if (tachesCompletedCount === tachesTotalCount) return 'termine';
            if (tachesCompletedCount > 0) return 'en_cours';
            return 'non_commence';
        }
        
        function getAllPhotosFromStorage() {
            const photos = [];
            
            // Chercher dans localStorage
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('uploaded_image_')) {
                    try {
                        const photoData = JSON.parse(localStorage.getItem(key) || '{}');
                        photos.push({
                            storageKey: key,
                            photoId: photoData.photoId || photoData.id,
                            url: photoData.url || photoData.uploadedUrl,
                            dataUrl: photoData.dataUrl,
                            pieceId: photoData.pieceId || photoData.metadata?.pieceId,
                            taskId: photoData.taskId || photoData.metadata?.taskId,
                            timestamp: photoData.timestamp,
                            metadata: photoData.metadata || photoData
                        });
                    } catch (e) {
                        console.warn('Erreur parsing photo:', key, e);
                    }
                }
            });
            
            return photos;
        }
        
        function determinePieceStatus(piece, sessionData, checkType) {
            // Logique pour d√©terminer le statut d'une pi√®ce
            if (piece.completed || piece.status === 'completed') return 'completed';
            if (piece.started || piece.status === 'started') return 'in_progress';
            if (piece.skipped || piece.status === 'skipped') return 'skipped';
            if (piece.locked || piece.status === 'locked') return 'locked';
            
            // V√©rifier dans les donn√©es de session
            const pieceKey = piece.piece_id || piece.id;
            if (sessionData[`${pieceKey}_completed`]) return 'completed';
            if (sessionData[`${pieceKey}_started`]) return 'in_progress';
            
            return 'pending';
        }
        
        function calculatePieceProgression(piece, sessionData) {
            if (piece.progression !== undefined) return piece.progression;
            if (piece.progress !== undefined) return piece.progress;
            
            // Calculer bas√© sur les t√¢ches
            const completedTasks = countCompletedTasks(piece, sessionData);
            const totalTasks = countTotalTasks(piece);
            
            if (totalTasks > 0) {
                return Math.round((completedTasks / totalTasks) * 100);
            }
            
            return 0;
        }
        
        function countCompletedTasks(piece, sessionData) {
            if (piece.tasks && Array.isArray(piece.tasks)) {
                return piece.tasks.filter(task => task.completed || task.status === 'completed').length;
            }
            return 0;
        }
        
        function countTotalTasks(piece) {
            if (piece.tasks && Array.isArray(piece.tasks)) {
                return piece.tasks.length;
            }
            return 1; // Minimum 1 pour √©viter division par 0
        }
        
        function extractCheckinPhotos(piece, sessionData, piecePhotos = []) {
            const photos = [];
            
            // 1. Photos de r√©f√©rence depuis la pi√®ce
            if (piece.checkin_pictures && Array.isArray(piece.checkin_pictures)) {
                photos.push(...piece.checkin_pictures.map(photo => ({
                    ...photo,
                    type: 'reference',
                    source: 'piece_data'
                })));
            }
            
            // 2. Photos depuis localStorage filtr√©es pour cette pi√®ce
            piecePhotos.forEach(photo => {
                if (photo.url || photo.dataUrl) {
                    photos.push({
                        photoId: photo.photoId,
                        url: photo.url,
                        dataUrl: photo.dataUrl,
                        timestamp: photo.timestamp,
                        taskId: photo.taskId,
                        type: 'uploaded',
                        source: 'localStorage',
                        metadata: photo.metadata
                    });
                }
            });
            
            // 3. Photos dans les donn√©es de session
            Object.keys(sessionData).forEach(key => {
                if (key.includes('checkin') && key.includes('photo')) {
                    const photoData = sessionData[key];
                    if (photoData && typeof photoData === 'object') {
                        photos.push({
                            ...photoData,
                            type: 'session',
                            source: 'session_data'
                        });
                    }
                }
            });
            
            console.log(`üì∏ CheckIn - Pi√®ce ${piece.piece_id || piece.id}: ${photos.length} photos extraites`);
            return photos;
        }
        
        function extractCheckoutPhotos(piece, sessionData, piecePhotos = []) {
            const photos = [];
            
            // V√©rifier d'abord si on est r√©ellement en phase checkout
            const sessionStateInfo = determineSessionState(sessionData);
            if (sessionStateInfo.state !== 'checkout') {
                console.log(`‚ö†Ô∏è Session non en checkout pour pi√®ce ${piece.piece_id || piece.id} - aucune photo checkout`);
                return [];
            }
            
            // 1. Photos de checkout depuis la pi√®ce
            if (piece.checkout_pictures && Array.isArray(piece.checkout_pictures)) {
                photos.push(...piece.checkout_pictures.map(photo => ({
                    ...photo,
                    type: 'reference',
                    source: 'piece_data'
                })));
            }
            
            // 2. Photos upload√©es sp√©cifiquement pour le checkout
            piecePhotos.forEach(photo => {
                if ((photo.url || photo.dataUrl) && isCheckoutPhoto(photo, sessionData)) {
                    photos.push({
                        photoId: photo.photoId,
                        url: photo.url,
                        dataUrl: photo.dataUrl,
                        timestamp: photo.timestamp,
                        taskId: photo.taskId,
                        type: 'uploaded',
                        source: 'localStorage',
                        metadata: photo.metadata
                    });
                }
            });
            
            // 3. Photos dans les donn√©es de session sp√©cifiquement marqu√©es checkout
            Object.keys(sessionData).forEach(key => {
                if (key.includes('checkout') && key.includes('photo')) {
                    const photoData = sessionData[key];
                    if (photoData && typeof photoData === 'object') {
                        photos.push({
                            ...photoData,
                            type: 'session',
                            source: 'session_data'
                        });
                    }
                }
            });
            
            console.log(`üì∏ CheckOut - Pi√®ce ${piece.piece_id || piece.id}: ${photos.length} photos checkout extraites`);
            return photos;
        }
        
        function extractReportedIssues(piece, sessionData) {
            const issues = [];
            
            // Chercher les signalements
            Object.keys(sessionData).forEach(key => {
                if (key.includes('signalement') || key.includes('issue') || key.includes('problem')) {
                    const issueData = sessionData[key];
                    if (issueData && typeof issueData === 'object') {
                        issues.push(issueData);
                    }
                }
            });
            
            return issues;
        }
        
        // === G√âN√âRATION ID UNIQUE ===
        
        function generateUniqueWebhookId(originalCheckId) {
            const sessionData = checkIdData[originalCheckId];
            
            // V√©rifier que sessionData existe
            if (!sessionData) {
                console.warn('‚ö†Ô∏è sessionData undefined pour CheckID:', originalCheckId);
                // G√©n√©rer un ID basique avec timestamp si pas de donn√©es de session
                return `webhook_${originalCheckId || 'unknown'}_${Date.now()}`;
            }
            
            // üéØ G√âN√âRATION ID PERSISTANT bas√© sur le contenu de la session
            const persistentId = generatePersistentId(originalCheckId, sessionData);
            
            // V√©rifier si cet ID existe d√©j√† dans la base locale
            const existingWebhookData = getStoredWebhookData(persistentId);
            
            if (existingWebhookData) {
                console.log('üîç ID persistant trouv√© dans la base:', {
                    persistentId: persistentId,
                    dernierEnvoi: existingWebhookData.lastSent,
                    nombreEnvois: existingWebhookData.sendCount
                });
                
                // Incr√©menter le compteur d'envois
                existingWebhookData.sendCount++;
                existingWebhookData.lastSent = new Date().toISOString();
                saveWebhookData(persistentId, existingWebhookData);
                
                return persistentId;
            } else {
                console.log('üÜî Nouvel ID persistant cr√©√©:', persistentId);
                
                // Sauvegarder les m√©tadonn√©es de ce nouveau webhook ID
                const webhookMetadata = {
                    id: persistentId,
                    originalCheckId: originalCheckId,
                    logement_id: sessionData.logement_id,
                    user_id: sessionData.user_id || sessionData.userId,
                    created: new Date().toISOString(),
                    lastSent: null,
                    sendCount: 0,
                    sessionFingerprint: createSessionFingerprint(sessionData)
                };
                
                saveWebhookData(persistentId, webhookMetadata);
                return persistentId;
            }
        }
        
        function generatePersistentId(checkId, sessionData) {
            // V√©rifier que sessionData existe
            if (!sessionData) {
                console.warn('‚ö†Ô∏è sessionData undefined dans generatePersistentId, utilisation de donn√©es par d√©faut');
                return `fallback_${checkId}_${Date.now()}`;
            }
            
            // Cr√©er un hash bas√© sur le contenu stable de la session
            const stableContent = {
                logement_id: sessionData.logement_id || '',
                user_id: sessionData.user_id || sessionData.userId || '',
                // Utiliser les √©tats des pi√®ces pour l'unicit√©
                roomStates: extractRoomStatesFromSession(sessionData),
                // Timestamp de cr√©ation de la session (si disponible)
                sessionTimestamp: sessionData.timestamp || sessionData.created || ''
            };
            
            // Cr√©er un hash simple mais reproductible
            const contentString = JSON.stringify(stableContent);
            const hash = simpleHash(contentString);
            
            // Format: persistent_HASH_logementId
            const logementSuffix = sessionData.logement_id ? `_${sessionData.logement_id}` : '';
            return `persistent_${hash}${logementSuffix}`;
        }
        
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32bit integer
            }
            return Math.abs(hash).toString(36);
        }
        
        function createSessionFingerprint(sessionData) {
            // Empreinte pour d√©tecter les changements significatifs
            return {
                roomCount: Object.keys(extractRoomStatesFromSession(sessionData)).length,
                hasPhotos: getAllPhotosFromStorage().length > 0,
                lastModified: sessionData.timestamp || new Date().toISOString()
            };
        }
        
        function getStoredWebhookData(webhookId) {
            try {
                const stored = localStorage.getItem(`webhook_metadata_${webhookId}`);
                return stored ? JSON.parse(stored) : null;
            } catch (e) {
                console.warn('Erreur lecture webhook metadata:', e);
                return null;
            }
        }
        
        function saveWebhookData(webhookId, metadata) {
            try {
                localStorage.setItem(`webhook_metadata_${webhookId}`, JSON.stringify(metadata));
                console.log('üíæ M√©tadonn√©es webhook sauvegard√©es:', webhookId);
            } catch (e) {
                console.error('Erreur sauvegarde webhook metadata:', e);
            }
        }
        
        function getAllStoredWebhooks() {
            const webhooks = [];
            Object.keys(localStorage).forEach(key => {
                if (key.startsWith('webhook_metadata_')) {
                    try {
                        const data = JSON.parse(localStorage.getItem(key));
                        webhooks.push(data);
                    } catch (e) {
                        console.warn('Webhook metadata corrompu:', key);
                    }
                }
            });
            return webhooks.sort((a, b) => new Date(b.created) - new Date(a.created));
        }
        
        // === EXTRACTION PARCOURS & LOGEMENT ===
        
        function extractParcoursLogementInfo(sessionData) {
            console.log('üè† Extraction parcours/logement depuis:', sessionData);
            
            const parcoursLogementInfo = {
                parcours_id: null,
                parcours_name: null,
                logement_id: null,
                logement_name: null,
                extraction_source: 'non_trouve'
            };
            
            // V√©rifier que sessionData existe
            if (!sessionData) {
                console.warn('‚ö†Ô∏è sessionData est undefined, retour de donn√©es par d√©faut');
                return parcoursLogementInfo;
            }
            
            // üéØ M√âTHODE 1: Depuis sessionData.parcoursInfo (structure principale)
            if (sessionData.parcoursInfo) {
                console.log('‚úÖ parcoursInfo trouv√© dans sessionData:', sessionData.parcoursInfo);
                parcoursLogementInfo.parcours_id = sessionData.parcoursInfo.id || sessionData.parcoursId || null;
                parcoursLogementInfo.parcours_name = sessionData.parcoursInfo.name || null;
                parcoursLogementInfo.logement_id = sessionData.parcoursInfo.logement_id || sessionData.logement_id || null;
                parcoursLogementInfo.logement_name = sessionData.parcoursInfo.logement || null;
                parcoursLogementInfo.extraction_source = 'session_parcoursInfo';
            }
            
            // üéØ M√âTHODE 2: Depuis les propri√©t√©s directes de session
            if (!parcoursLogementInfo.parcours_id && sessionData.parcoursId) {
                parcoursLogementInfo.parcours_id = sessionData.parcoursId;
                parcoursLogementInfo.extraction_source = 'session_direct';
            }
            
            if (!parcoursLogementInfo.logement_id && sessionData.logement_id) {
                parcoursLogementInfo.logement_id = sessionData.logement_id;
                if (!parcoursLogementInfo.extraction_source.includes('session')) {
                    parcoursLogementInfo.extraction_source = 'session_direct';
                }
            }
            
            // üéØ M√âTHODE 3: Depuis l'URL actuelle (si elle contient les param√®tres)
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const parcoursFromUrl = urlParams.get('parcours');
                
                if (!parcoursLogementInfo.parcours_id && parcoursFromUrl) {
                    parcoursLogementInfo.parcours_id = parcoursFromUrl;
                    parcoursLogementInfo.extraction_source = 'url_params';
                    console.log('üîó Parcours ID r√©cup√©r√© depuis URL:', parcoursFromUrl);
                }
            } catch (e) {
                console.warn('‚ö†Ô∏è Erreur lecture URL params:', e);
            }
            
            // üéØ M√âTHODE 4: Depuis les contextes globaux React (si accessibles via localStorage)
            try {
                // Chercher dans les donn√©es de parcours global
                const globalParcoursData = localStorage.getItem('current-parcours');
                if (!parcoursLogementInfo.parcours_id && globalParcoursData) {
                    const parsed = JSON.parse(globalParcoursData);
                    if (parsed.id) {
                        parcoursLogementInfo.parcours_id = parsed.id;
                        parcoursLogementInfo.parcours_name = parsed.name || parsed.parcoursName || null;
                        parcoursLogementInfo.logement_name = parsed.logement || parsed.logementName || null;
                        parcoursLogementInfo.extraction_source = 'global_parcours';
                        console.log('üåê Donn√©es parcours depuis global storage:', parsed);
                    }
                }
            } catch (e) {
                console.warn('‚ö†Ô∏è Erreur lecture global parcours:', e);
            }
            
            // üéØ M√âTHODE 5: Depuis le cache parcours IndexedDB (si accessible)
            try {
                // Essayer de r√©cup√©rer depuis les cl√©s localStorage qui pourraient contenir l'info
                Object.keys(localStorage).forEach(key => {
                    if ((key.includes('parcours') || key.includes('logement')) && 
                        !parcoursLogementInfo.parcours_id) {
                        try {
                            const data = JSON.parse(localStorage.getItem(key) || '{}');
                            if (data.id && !parcoursLogementInfo.parcours_id) {
                                parcoursLogementInfo.parcours_id = data.id;
                                parcoursLogementInfo.parcours_name = data.name || data.parcoursName || null;
                                parcoursLogementInfo.logement_name = data.logement || data.logementName || null;
                                parcoursLogementInfo.extraction_source = `localStorage_${key}`;
                                console.log(`üîë Donn√©es r√©cup√©r√©es depuis ${key}:`, data);
                            }
                        } catch (e) {
                            // Ignorer les erreurs de parsing
                        }
                    }
                });
            } catch (e) {
                console.warn('‚ö†Ô∏è Erreur analyse localStorage:', e);
            }
            
            console.log('üè† Parcours/Logement extraits:', parcoursLogementInfo);
            return parcoursLogementInfo;
        }
        
        // === EXTRACTION √âTAPES STRUCTUR√âES PAR PI√àCE ===
        
        function extractEtapesStructurees(sessionData, flowType) {
            console.log('üèóÔ∏è Extraction √©tapes structur√©es pour:', flowType);
            
            const etapesParPiece = [];
            
            // Utiliser les donn√©es API comme r√©f√©rence principale
            if (sessionData?.parcoursData?.piece) {
                console.log('‚úÖ Utilisation donn√©es API pour structure');
                
                sessionData.parcoursData.piece.forEach(piece => {
                    const pieceStructure = {
                        piece_id: piece.pieceID,
                        piece_name: piece.nom,
                        piece_info: {
                            traveler_note: piece.travelerNote || '',
                            cleaner_note: piece.cleanerNote || '',
                            info_entrance: piece.infoEntrance || ''
                        },
                        etapes: []
                    };
                    
                    if (piece.etapes && Array.isArray(piece.etapes)) {
                        piece.etapes.forEach((etape, index) => {
                            const etapeId = cleanEtapeId(etape.etapeID);
                            const interactions = analyseInteractionsPourEtape(sessionData, etapeId, piece.pieceID);
                            
                            const etapeStructure = {
                                etape_id: etapeId,
                                etape_original_id: etape.etapeID,
                                etape_index: index,
                                type: etape.isTodo ? 'todo' : 'photo',
                                status: interactions.completed ? 'completed' : 'pending',
                                
                                // Informations de l'√©tape
                                info: {
                                    is_todo: etape.isTodo || false,
                                    todo_title: etape.todoTitle || '',
                                    todo_order: etape.todoOrder || '',
                                    has_image: !!etape.image,
                                    reference_image: etape.image || '',
                                    todo_image: etape.todoImage || ''
                                },
                                
                                // Interactions de l'utilisateur
                                interactions: {
                                    completed_at: interactions.timestamp,
                                    photos: interactions.photosCount || 0,
                                    button_clicks: interactions.buttonClicks || 0,
                                    checkboxes: interactions.checkboxes || 0,
                                    total_interactions: interactions.totalInteractions || 0
                                },
                                
                                // M√©tadonn√©es pour debug si n√©cessaire
                                debug: interactions.debug || {}
                            };
                            
                            pieceStructure.etapes.push(etapeStructure);
                        });
                    }
                    
                    // Statistiques de la pi√®ce
                    pieceStructure.statistiques = {
                        total_etapes: pieceStructure.etapes.length,
                        etapes_completees: pieceStructure.etapes.filter(e => e.status === 'completed').length,
                        etapes_photos: pieceStructure.etapes.filter(e => e.type === 'photo').length,
                        etapes_todos: pieceStructure.etapes.filter(e => e.type === 'todo').length,
                        completion_percentage: pieceStructure.etapes.length > 0 
                            ? Math.round((pieceStructure.etapes.filter(e => e.status === 'completed').length / pieceStructure.etapes.length) * 100)
                            : 0
                    };
                    
                    etapesParPiece.push(pieceStructure);
                });
            } else {
                console.log('‚ö†Ô∏è Pas de donn√©es API, utilisation fallback');
                // TODO: Fallback vers les donn√©es locales si pas d'API
            }
            
            console.log(`üèóÔ∏è ${etapesParPiece.length} pi√®ces structur√©es avec ${etapesParPiece.reduce((acc, p) => acc + p.etapes.length, 0)} √©tapes`);
            return etapesParPiece;
        }
        
        // === ANALYSE INTERACTIONS POUR UNE √âTAPE ===
        
        function analyseInteractionsPourEtape(sessionData, etapeId, pieceId) {
            console.log('üîç Analyse interactions pour √©tape:', { etapeId, pieceId });
            
            const result = {
                completed: false,
                timestamp: null,
                photosCount: 0,
                buttonClicks: 0,
                checkboxes: 0,
                totalInteractions: 0,
                debug: {
                    sources_found: [],
                    raw_data: {}
                }
            };
            
            // Chercher dans buttonClicks
            if (sessionData.progress?.interactions?.buttonClicks) {
                Object.entries(sessionData.progress.interactions.buttonClicks).forEach(([key, clickData]) => {
                    if (key.includes(etapeId) || key.includes(pieceId)) {
                        const click = Array.isArray(clickData) ? clickData[0] : clickData;
                        if (click.etapeId === etapeId || key.includes(etapeId)) {
                            result.completed = true;
                            result.buttonClicks++;
                            result.totalInteractions++;
                            result.timestamp = click.timestamp || result.timestamp;
                            result.debug.sources_found.push('buttonClicks');
                            result.debug.raw_data.buttonClick = click;
                        }
                    }
                });
            }
            
            // Chercher dans photos
            if (sessionData.progress?.interactions?.photos || sessionData.progress?.interactions?.photosTaken) {
                const photosData = sessionData.progress.interactions.photos || sessionData.progress.interactions.photosTaken || {};
                Object.entries(photosData).forEach(([key, photoData]) => {
                    if (key.includes(etapeId) || key.includes(pieceId)) {
                        const photo = Array.isArray(photoData) ? photoData[0] : photoData;
                        if (photo.etapeId === etapeId || key.includes(etapeId)) {
                            result.completed = true;
                            result.photosCount++;
                            result.totalInteractions++;
                            result.timestamp = photo.timestamp || result.timestamp;
                            result.debug.sources_found.push('photos');
                            result.debug.raw_data.photo = photo;
                        }
                    }
                });
            }
            
            // Chercher dans checkboxes
            if (sessionData.progress?.interactions?.checkboxes) {
                Object.entries(sessionData.progress.interactions.checkboxes).forEach(([key, checkboxData]) => {
                    if (key.includes(etapeId) || key.includes(pieceId)) {
                        const checkbox = Array.isArray(checkboxData) ? checkboxData[0] : checkboxData;
                        if (checkbox.etapeId === etapeId || key.includes(etapeId)) {
                            result.completed = checkbox.isChecked || false;
                            result.checkboxes++;
                            result.totalInteractions++;
                            result.timestamp = checkbox.timestamp || result.timestamp;
                            result.debug.sources_found.push('checkboxes');
                            result.debug.raw_data.checkbox = checkbox;
                        }
                    }
                });
            }
            
            console.log('üìä Analyse termin√©e:', result);
            return result;
        }
        
        // === EXTRACTION √âTAPES D√âTAILS ===
        
        function extractEtapesDetails(sessionData, piecesData) {
            console.log('üéØ Extraction des d√©tails des √©tapes depuis:', { sessionData, piecesData });
            
            const etapesDetails = {
                etapes_completees: [],
                etapes_en_cours: [],
                photos_par_etape: {},
                taches_par_etape: {},
                reference_api_etapes: [],  // Nouveau: r√©f√©rence des √©tapes API
                statistiques: {
                    total_etapes: 0,
                    etapes_completees_count: 0,
                    etapes_avec_photos: 0,
                    total_photos: 0,
                    etapes_api_disponibles: 0  // Nouveau
                }
            };
            
            // üéØ NOUVEAU: Utiliser d'abord les donn√©es API comme r√©f√©rence
            if (sessionData?.parcoursData?.piece) {
                console.log('‚úÖ Utilisation des donn√©es API comme r√©f√©rence');
                extractFromApiReference(sessionData.parcoursData, etapesDetails);
            }
            
            // üéØ FONCTION: Trouver les interactions pour une √©tape donn√©e
            function findInteractionsForEtape(sessionData, etapeId, pieceId) {
                let completed = false;
                let timestamp = null;
                let count = 0;
                
                // Chercher dans buttonClicks
                if (sessionData.interactions?.buttonClicks) {
                    Object.keys(sessionData.interactions.buttonClicks).forEach(key => {
                        if (key.includes(etapeId) || key.includes(pieceId)) {
                            const interaction = sessionData.interactions.buttonClicks[key];
                            if (interaction.etapeId === etapeId || key.includes(etapeId)) {
                                completed = true;
                                timestamp = interaction.timestamp || timestamp;
                                count++;
                            }
                        }
                    });
                }
                
                // Chercher dans photos
                if (sessionData.interactions?.photos) {
                    Object.keys(sessionData.interactions.photos).forEach(key => {
                        if (key.includes(etapeId) || key.includes(pieceId)) {
                            const photo = sessionData.interactions.photos[key];
                            if (photo.etapeId === etapeId || key.includes(etapeId)) {
                                completed = true;
                                timestamp = photo.timestamp || timestamp;
                                count++;
                            }
                        }
                    });
                }
                
                // Chercher dans checkboxes
                if (sessionData.interactions?.checkboxes) {
                    Object.keys(sessionData.interactions.checkboxes).forEach(key => {
                        if (key.includes(etapeId) || key.includes(pieceId)) {
                            const checkbox = sessionData.interactions.checkboxes[key];
                            if (checkbox.etapeId === etapeId || key.includes(etapeId)) {
                                completed = checkbox.checked || false;
                                timestamp = checkbox.timestamp || timestamp;
                                count++;
                            }
                        }
                    });
                }
                
                return { completed, timestamp, count };
            }

            // üéØ FONCTION: Extraire les √©tapes depuis les donn√©es API
            function extractFromApiReference(parcoursData, etapesDetails) {
                console.log('üì° Extraction depuis donn√©es API:', parcoursData);
                
                if (!parcoursData.piece || !Array.isArray(parcoursData.piece)) {
                    console.log('‚ùå Pas de pi√®ces dans parcoursData');
                    return;
                }
                
                parcoursData.piece.forEach(piece => {
                    if (piece.etapes && Array.isArray(piece.etapes)) {
                        piece.etapes.forEach(etape => {
                            const etapeId = cleanEtapeId(etape.etapeID);
                            if (etapeId) {
                                const etapeRef = {
                                    etapeId: etapeId,
                                    pieceId: piece.pieceID,
                                    pieceName: piece.nom,
                                    originalEtapeId: etape.etapeID,
                                    isTodo: etape.isTodo || false,
                                    hasImage: !!etape.image,
                                    todoTitle: etape.todoTitle || '',
                                    image: etape.image || ''
                                };
                                
                                etapesDetails.reference_api_etapes.push(etapeRef);
                                etapesDetails.statistiques.etapes_api_disponibles++;
                                
                                console.log('üéØ √âtape API ajout√©e:', etapeRef);
                            }
                        });
                    }
                });
                
                console.log(`üìä ${etapesDetails.statistiques.etapes_api_disponibles} √©tapes API extraites`);
            }
            
            // üéØ FONCTION UTILITAIRE: Nettoyer automatiquement les etapeIDs
            function cleanEtapeId(etapeId) {
                if (!etapeId) return undefined;
                // Extraire seulement la partie au format timestampXrandom
                const etapeIdMatch = etapeId.match(/(\d+x\d+)/);
                const cleanId = etapeIdMatch ? etapeIdMatch[1] : etapeId;
                
                if (cleanId !== etapeId) {
                    console.log('üßπ EtapeId nettoy√© automatiquement:', { original: etapeId, cleaned: cleanId });
                }
                
                return cleanId;
            }
            
            // üéØ FONCTION UTILITAIRE: G√©n√©rer un etapeID unique si manquant
            function ensureUniqueEtapeId(rawEtapeId, pieceId, etapeIndex = 0) {
                // Si pas d'etapeId ou si etapeId = pieceId, g√©n√©rer un ID unique
                if (!rawEtapeId || rawEtapeId === pieceId) {
                    const timestamp = Date.now();
                    const randomSuffix = Math.floor(Math.random() * 1000000000000000000); // 18 chiffres
                    const generatedId = `${timestamp}x${randomSuffix}`;
                    
                    console.log('üîÑ EtapeId manquant ou dupliqu√© - g√©n√©ration automatique:', {
                        pieceId: pieceId,
                        etapeIndex: etapeIndex,
                        originalEtapeId: rawEtapeId,
                        generatedEtapeId: generatedId,
                        reason: rawEtapeId ? 'duplicate_with_piece' : 'missing'
                    });
                    
                    return generatedId;
                }
                
                // Si etapeId existe et est diff√©rent du pieceId, le nettoyer normalement
                return cleanEtapeId(rawEtapeId);
            }
            
            try {
                // üéØ M√âTHODE 1: Priorit√© aux √©tapes API, puis fallback vers piecesData
                if (etapesDetails.reference_api_etapes.length > 0) {
                    console.log('‚úÖ Utilisation des √©tapes API comme source principale');
                        etapesDetails.reference_api_etapes.forEach(etapeApi => {
                        // Chercher les interactions pour cette √©tape dans les donn√©es locales
                        const interactions = findInteractionsForEtape(sessionData, etapeApi.etapeId, etapeApi.pieceId);
                        
                        const etapeDetail = {
                            etape_id: etapeApi.etapeId,  // üéØ ID nettoy√© depuis API
                            original_etape_id: etapeApi.originalEtapeId, // ID complet original
                            piece_id: etapeApi.pieceId,
                            piece_name: etapeApi.pieceName,
                            status: interactions.completed ? 'completed' : 'pending',
                            type: etapeApi.isTodo ? 'todo' : 'photo',
                            description: etapeApi.todoTitle || `Photo ${etapeApi.pieceName}`,
                            timestamp: interactions.timestamp || new Date().toISOString(),
                            has_api_reference: true,
                            interactions_count: interactions.count,
                            // üéØ NOUVEAU: M√©tadonn√©es pour debug
                            api_data: {
                                isTodo: etapeApi.isTodo,
                                hasImage: etapeApi.hasImage,
                                image: etapeApi.image
                            }
                        };
                        
                        if (etapeDetail.status === 'completed') {
                            etapesDetails.etapes_completees.push(etapeDetail);
                            etapesDetails.statistiques.etapes_completees_count++;
                        } else {
                            etapesDetails.etapes_en_cours.push(etapeDetail);
                        }
                        
                        etapesDetails.statistiques.total_etapes++;
                    });
                    
                } else if (piecesData && Array.isArray(piecesData)) {
                    console.log('‚ö†Ô∏è Fallback: Extraction depuis piecesData (pas de donn√©es API)');
                    piecesData.forEach(pieceInfo => {
                        console.log('üè† Analyse de la pi√®ce:', pieceInfo);
                        
                        // R√©cup√©rer les t√¢ches/√©tapes de cette pi√®ce
                        const pieceTasks = pieceInfo.taches_menage || pieceInfo.photos || [];
                        
                        pieceTasks.forEach((tache, etapeIndex) => {
                            const rawEtapeId = tache.etape_id || tache.etapeID || tache.task_id || tache.id;
                            const pieceId = pieceInfo.piece?.id || pieceInfo.piece_id;
                            
                            // üéØ NOUVEAU: G√©n√©rer ID unique si manquant ou dupliqu√© avec pieceId
                            const etapeId = ensureUniqueEtapeId(rawEtapeId, pieceId, etapeIndex);
                            
                            if (etapeId) {
                                etapesDetails.statistiques.total_etapes++;
                                
                                const etapeDetail = {
                                    etape_id: etapeId,  // üéØ ID nettoy√©
                                    piece_id: pieceInfo.piece?.id || pieceInfo.piece_id,
                                    piece_name: pieceInfo.piece?.nom || pieceInfo.piece_name,
                                    status: tache.completed || tache.is_completed ? 'completed' : 'pending',
                                    type: tache.type || 'unknown',
                                    description: tache.description || tache.label || '',
                                    timestamp: tache.timestamp || new Date().toISOString(),
                                    has_api_reference: false
                                };
                                
                                // Classer selon le statut
                                if (etapeDetail.status === 'completed') {
                                    etapesDetails.etapes_completees.push(etapeDetail);
                                    etapesDetails.statistiques.etapes_completees_count++;
                                } else {
                                    etapesDetails.etapes_en_cours.push(etapeDetail);
                                }
                                
                                // Photos associ√©es √† cette √©tape
                                const photosEtape = [];
                                if (tache.photos && Array.isArray(tache.photos)) {
                                    tache.photos.forEach(photo => {
                                        photosEtape.push({
                                            photo_id: photo.id || photo.photo_id,
                                            url: photo.dataUrl || photo.url,
                                            taken_at: photo.takenAt || photo.timestamp,
                                            uploaded: !!(photo.dataUrl || photo.url)
                                        });
                                        etapesDetails.statistiques.total_photos++;
                                    });
                                }
                                
                                if (photosEtape.length > 0) {
                                    etapesDetails.photos_par_etape[etapeId] = photosEtape;
                                    etapesDetails.statistiques.etapes_avec_photos++;
                                }
                                
                                // T√¢ches sp√©cifiques √† cette √©tape
                                etapesDetails.taches_par_etape[etapeId] = {
                                    completed: etapeDetail.status === 'completed',
                                    type: etapeDetail.type,
                                    description: etapeDetail.description,
                                    piece_context: {
                                        piece_id: etapeDetail.piece_id,
                                        piece_name: etapeDetail.piece_name
                                    }
                                };
                            }
                        });
                    });
                }
                
                // üéØ M√âTHODE 2: Extraire depuis les buttonClicks avec les nouveaux etapeId
                if (sessionData.progress?.interactions?.buttonClicks) {
                    const buttonClicks = sessionData.progress.interactions.buttonClicks;
                    
                    console.log('üñ±Ô∏è ButtonClicks avec etapeId trouv√©s:', Object.keys(buttonClicks));
                    
                    Object.entries(buttonClicks).forEach(([compositeKey, clickDataArray]) => {
                        // Parse la nouvelle cl√© : pieceId_etapeId_buttonId_timestamp
                        const keyParts = compositeKey.split('_');
                        
                        if (keyParts.length >= 4) {  // Nouvelle structure avec etapeId
                            const pieceId = keyParts[0];
                            const rawEtapeId = keyParts[1];
                            const buttonId = keyParts[2];
                            
                            // üéØ NETTOYAGE AUTOMATIQUE de l'etapeId depuis la cl√©
                            const etapeId = cleanEtapeId(rawEtapeId);
                            
                            // Extraire les donn√©es de l'interaction
                            const clickData = Array.isArray(clickDataArray) ? clickDataArray[0] : clickDataArray;
                            
                            if (etapeId) {  // V√©rifier que l'etapeId nettoy√© est pr√©sent
                                const existeDeja = etapesDetails.etapes_completees.some(etape => etape.etape_id === etapeId);
                                
                                if (!existeDeja) {
                                    etapesDetails.etapes_completees.push({
                                        etape_id: etapeId,
                                        piece_id: pieceId,
                                        piece_name: clickData.metadata?.pieceName || 'unknown',
                                        status: 'completed',
                                        type: 'button_click',
                                        description: `${clickData.actionType} - ${buttonId}`,
                                        timestamp: clickData.timestamp || new Date().toISOString(),
                                        source: 'buttonClicks_with_etapeId'
                                    });
                                    etapesDetails.statistiques.etapes_completees_count++;
                                    etapesDetails.statistiques.total_etapes++;
                                }
                            }
                        } else if (keyParts.length >= 2) {
                            // Ancienne structure sans etapeId pour compatibilit√©
                            const pieceId = keyParts[0];
                            const rawTaskId = keyParts[1];
                            
                            // üéØ NETTOYAGE AUTOMATIQUE m√™me pour l'ancienne structure
                            const taskId = cleanEtapeId(rawTaskId);
                            
                            const existeDeja = etapesDetails.etapes_completees.some(etape => etape.etape_id === taskId);
                            
                            if (!existeDeja) {
                                etapesDetails.etapes_completees.push({
                                    etape_id: taskId,
                                    piece_id: pieceId,
                                    piece_name: 'unknown',
                                    status: 'completed',
                                    type: 'task_legacy',
                                    description: `T√¢che ${taskId}`,
                                    timestamp: new Date().toISOString(),
                                    source: 'buttonClicks_legacy'
                                });
                                etapesDetails.statistiques.etapes_completees_count++;
                                etapesDetails.statistiques.total_etapes++;
                            }
                        }
                    });
                }
                
                // üéØ M√âTHODE 2b: Fallback avec completedTaskIds pour compatibilit√©
                if (sessionData.progress?.completedTaskIds) {
                    const completedTaskIds = Array.isArray(sessionData.progress.completedTaskIds) 
                        ? sessionData.progress.completedTaskIds 
                        : Array.from(sessionData.progress.completedTaskIds);
                        
                    console.log('üìã T√¢ches compl√©t√©es (fallback) trouv√©es:', completedTaskIds);
                    
                    completedTaskIds.forEach(rawTaskId => {
                        // üéØ NETTOYAGE AUTOMATIQUE pour les completedTaskIds
                        const taskId = cleanEtapeId(rawTaskId);
                        
                        // V√©rifier si cette t√¢che n'est pas d√©j√† dans nos √©tapes compl√©t√©es
                        const existeDeja = etapesDetails.etapes_completees.some(etape => etape.etape_id === taskId);
                        
                        if (!existeDeja) {
                            etapesDetails.etapes_completees.push({
                                etape_id: taskId,  // üéØ ID nettoy√©
                                piece_id: 'unknown',
                                piece_name: 'unknown',
                                status: 'completed',
                                type: 'task_fallback',
                                description: `T√¢che ${taskId}`,
                                timestamp: new Date().toISOString(),
                                source: 'completedTaskIds_fallback'
                            });
                            etapesDetails.statistiques.etapes_completees_count++;
                            etapesDetails.statistiques.total_etapes++;
                        }
                    });
                }
                
                // üéØ M√âTHODE 3: Extraire depuis les photos captur√©es (capturedPhotosData, takenPhotos)
                if (sessionData.progress?.takenPhotos) {
                    Object.entries(sessionData.progress.takenPhotos).forEach(([key, photos]) => {
                        // La cl√© peut √™tre au format "pieceId_etapeId"
                        const parts = key.split('_');
                        if (parts.length >= 2) {
                            const pieceId = parts[0];
                            const rawEtapeId = parts[1];
                            
                            // üéØ NETTOYAGE AUTOMATIQUE de l'etapeId depuis la cl√© photos
                            const etapeId = cleanEtapeId(rawEtapeId);
                            
                            if (!etapesDetails.photos_par_etape[etapeId]) {
                                etapesDetails.photos_par_etape[etapeId] = [];
                            }
                            
                            if (Array.isArray(photos)) {
                                photos.forEach(photo => {
                                    etapesDetails.photos_par_etape[etapeId].push({
                                        photo_id: photo.id || `photo_${Date.now()}`,
                                        url: photo.dataUrl || photo.url,
                                        taken_at: photo.takenAt || photo.timestamp,
                                        uploaded: !!(photo.dataUrl || photo.url),
                                        piece_context: pieceId
                                    });
                                    etapesDetails.statistiques.total_photos++;
                                });
                                
                                if (photos.length > 0) {
                                    etapesDetails.statistiques.etapes_avec_photos++;
                                }
                            }
                        }
                    });
                }
                
                // üéØ Log final avec comptage des nettoyages
                const totalEtapes = etapesDetails.statistiques.total_etapes;
                const etapesCompletes = etapesDetails.statistiques.etapes_completees_count;
                
                console.log('‚úÖ Extraction √©tapes termin√©e:', {
                    total_etapes: totalEtapes,
                    etapes_completees: etapesCompletes,
                    nettoyage_automatique: 'üßπ Tous les etapeID ont √©t√© nettoy√©s automatiquement',
                    format_final: 'timestampXrandom uniquement'
                });
                console.log('üìã D√©tails des √©tapes:', etapesDetails);
                
            } catch (error) {
                console.error('‚ùå Erreur lors de l\'extraction des √©tapes:', error);
                etapesDetails.error = error.message;
            }
            
            return etapesDetails;
        }
        
        // === EXTRACTION DONN√âES UTILISATEUR ===
        
        function extractUserVerificationData(sessionData) {
            console.log('üë§ Extraction des donn√©es utilisateur depuis:', sessionData);
            
            const userVerificationData = {
                user_info: null,
                connexion_info: null,
                verification_status: 'non_verifie'
            };
            
            // V√©rifier que sessionData existe
            if (!sessionData) {
                console.warn('‚ö†Ô∏è sessionData est undefined, retour de donn√©es par d√©faut');
                return userVerificationData;
            }
            
            // üéØ M√âTHODE 1: Depuis sessionData.userInfo (structure principale)
            if (sessionData.userInfo) {
                console.log('‚úÖ UserInfo trouv√© dans sessionData:', sessionData.userInfo);
                userVerificationData.user_info = {
                    firstName: sessionData.userInfo.firstName || '',
                    lastName: sessionData.userInfo.lastName || '', 
                    phone: sessionData.userInfo.phone || '',
                    type: sessionData.userInfo.type || 'UNKNOWN',
                    type_label: sessionData.userInfo.type === 'CLIENT' ? 'Voyageur' : 
                               sessionData.userInfo.type === 'AGENT' ? 'Agent M√©nage' : 'Inconnu',
                    registeredAt: sessionData.userInfo.registeredAt || null
                };
                userVerificationData.verification_status = 'verifie_session';
            }
            
            // üéØ M√âTHODE 2: Depuis localStorage userInfo (fallback)
            if (!userVerificationData.user_info || !userVerificationData.user_info.firstName) {
                try {
                    const localUserInfo = JSON.parse(localStorage.getItem('userInfo') || '{}');
                    console.log('üîç UserInfo depuis localStorage:', localUserInfo);
                    
                    if (localUserInfo.firstName || localUserInfo.phone) {
                        userVerificationData.user_info = {
                            firstName: localUserInfo.firstName || '',
                            lastName: localUserInfo.lastName || '',
                            phone: localUserInfo.phone || sessionData.user_id || sessionData.userId || '',
                            type: localUserInfo.type || 'UNKNOWN',
                            type_label: localUserInfo.type === 'CLIENT' ? 'Voyageur' :
                                       localUserInfo.type === 'AGENT' ? 'Agent M√©nage' : 'Inconnu',
                            registeredAt: localUserInfo.registeredAt || null
                        };
                        userVerificationData.verification_status = 'verifie_localstorage';
                    }
                } catch (e) {
                    console.warn('‚ö†Ô∏è Erreur lecture localStorage userInfo:', e);
                }
            }
            
            // üéØ M√âTHODE 3: Depuis registeredUsers (base utilisateurs enregistr√©s)
            if (!userVerificationData.user_info || !userVerificationData.user_info.firstName) {
                try {
                    const registeredUsers = JSON.parse(localStorage.getItem('registeredUsers') || '{}');
                    const userId = sessionData.user_id || sessionData.userId;
                    
                    if (userId && registeredUsers[userId]) {
                        const userData = registeredUsers[userId];
                        console.log('üîç UserInfo depuis registeredUsers:', userData);
                        
                        userVerificationData.user_info = {
                            firstName: userData.firstName || '',
                            lastName: userData.lastName || '',
                            phone: userId,
                            type: sessionData.userType || 'UNKNOWN',
                            type_label: sessionData.userType === 'CLIENT' ? 'Voyageur' :
                                       sessionData.userType === 'AGENT' ? 'Agent M√©nage' : 'Inconnu',
                            registeredAt: userData.registeredAt || null
                        };
                        userVerificationData.verification_status = 'verifie_registered_users';
                    }
                } catch (e) {
                    console.warn('‚ö†Ô∏è Erreur lecture registeredUsers:', e);
                }
            }
            
            // üéØ M√âTHODE 4: Informations basiques si rien trouv√©
            if (!userVerificationData.user_info) {
                userVerificationData.user_info = {
                    firstName: '',
                    lastName: '',
                    phone: sessionData.user_id || sessionData.userId || '',
                    type: 'UNKNOWN',
                    type_label: 'Non identifi√©',
                    registeredAt: null
                };
                userVerificationData.verification_status = 'non_trouve';
            }
            
            // Informations de connexion
            userVerificationData.connexion_info = {
                session_created: sessionData.timestamp || sessionData.created || new Date().toISOString(),
                logement_id: sessionData.logement_id || null,
                parcours_type: getSessionType(sessionData),
                session_duration: sessionData.sessionDuration || calculateSessionDuration(sessionData),
                device_info: sessionData.deviceInfo || getDeviceInfo()
            };
            
            console.log('üë§ Donn√©es utilisateur extraites:', userVerificationData);
            return userVerificationData;
        }
        
        function calculateSessionDuration(sessionData) {
            if (!sessionData.timestamp && !sessionData.created) return null;
            
            const startTime = new Date(sessionData.timestamp || sessionData.created);
            const currentTime = new Date();
            const durationMs = currentTime - startTime;
            const durationMinutes = Math.round(durationMs / (1000 * 60));
            
            return `${durationMinutes} minutes`;
        }
        
        function getDeviceInfo() {
            return {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                screenResolution: `${screen.width}x${screen.height}`,
                timestamp: new Date().toISOString()
            };
        }
        
        // === FONCTIONS HELPER POUR CLASSIFICATION ===
        
         function extractRoomStatesFromSession(sessionData) {
             const roomStates = {};
             
             console.log('üîç extractRoomStatesFromSession - Donn√©es d\'entr√©e:', sessionData);
             
             // V√©rifier que sessionData existe
             if (!sessionData) {
                 console.warn('‚ö†Ô∏è sessionData undefined dans extractRoomStatesFromSession');
                 return roomStates;
             }
             
             // Chercher dans progress.interactions.buttonClicks (votre format sp√©cifique)
             if (sessionData.progress?.interactions?.buttonClicks) {
                 console.log('üîç Progress.interactions.buttonClicks trouv√©s:', Object.keys(sessionData.progress.interactions.buttonClicks));
                 
                 Object.entries(sessionData.progress.interactions.buttonClicks).forEach(([compositeKey, clickDataArray]) => {
                     console.log('üîç Analyse progress cl√©:', compositeKey, 'Donn√©es:', clickDataArray);
                     
                     // Le clickDataArray est un tableau, prendre le dernier √©l√©ment (plus r√©cent)
                     const clickData = Array.isArray(clickDataArray) ? clickDataArray[clickDataArray.length - 1] : clickDataArray;
                     
                     if (clickData) {
                         const pieceId = clickData.pieceId;
                         const actionType = clickData.actionType; // "correct" ou "deplorable"
                         const metadata = clickData.metadata || {};
                         
                         if (pieceId && actionType) {
                             console.log(`üè† Pi√®ce trouv√©e: ${pieceId}, √âtat: ${actionType}, Commentaire: ${metadata.comment || 'aucun'}`);
                             
                             roomStates[pieceId] = {
                                 state: actionType,
                                 comment: metadata.comment || null,
                                 timestamp: metadata.timestamp || clickData.timestamp || new Date().toISOString(),
                                 photoUrls: metadata.photoUrls || [],
                                 roomName: metadata.roomName || getPieceName(pieceId),
                                 page: metadata.page || 'etat-initial'
                             };
                         }
                     }
                 });
             }
             
             // Chercher dans buttonClicks (format principal)
             if (sessionData.buttonClicks) {
                 console.log('üîç ButtonClicks trouv√©s:', Object.keys(sessionData.buttonClicks));
                 
                 Object.entries(sessionData.buttonClicks).forEach(([compositeKey, clickDataArray]) => {
                     console.log('üîç Analyse cl√©:', compositeKey, 'Donn√©es:', clickDataArray);
                     
                     // Le clickDataArray est un tableau, prendre le dernier √©l√©ment (plus r√©cent)
                     const clickData = Array.isArray(clickDataArray) ? clickDataArray[clickDataArray.length - 1] : clickDataArray;
                     
                     if (clickData) {
                         const pieceId = clickData.pieceId;
                         const actionType = clickData.actionType; // "correct" ou "deplorable"
                         const metadata = clickData.metadata || {};
                         
                         if (pieceId && actionType) {
                             // Ne pas √©craser si d√©j√† trouv√© dans progress
                             if (!roomStates[pieceId]) {
                                 console.log(`üè† Pi√®ce trouv√©e dans buttonClicks: ${pieceId}, √âtat: ${actionType}, Commentaire: ${metadata.comment || 'aucun'}`);
                                 
                                 roomStates[pieceId] = {
                                     state: actionType,
                                     comment: metadata.comment || null,
                                     timestamp: metadata.timestamp || clickData.timestamp || new Date().toISOString(),
                                     photoUrls: metadata.photoUrls || [],
                                     roomName: metadata.roomName || getPieceName(pieceId),
                                     page: metadata.page || 'etat-initial'
                                 };
                             }
                         } else {
                             // Format alternatif: essayer d'extraire depuis le buttonId
                             if (clickData.buttonId) {
                                 const match = clickData.buttonId.match(/^etat-initial-(.+)-(correct|deplorable)$/);
                                 if (match) {
                                     const [, roomId, state] = match;
                                     
                                     if (!roomStates[roomId]) {
                                         console.log(`üè† Pi√®ce extraite depuis buttonId: ${roomId}, √âtat: ${state}`);
                                         
                                         roomStates[roomId] = {
                                             state: state,
                                             comment: metadata.comment || null,
                                             timestamp: metadata.timestamp || clickData.timestamp || new Date().toISOString(),
                                             photoUrls: metadata.photoUrls || [],
                                             roomName: metadata.roomName || getPieceName(roomId),
                                             page: metadata.page || 'etat-initial'
                                         };
                                     }
                                 }
                             }
                         }
                     }
                 });
             }
             
             // Chercher aussi dans interactionTracker (format secondaire)
             if (sessionData.interactionTracker?.buttonClicks) {
                 console.log('üîç InteractionTracker buttonClicks trouv√©s');
                 Object.entries(sessionData.interactionTracker.buttonClicks).forEach(([buttonId, clickData]) => {
                     const match = buttonId.match(/^etat-initial-(.+)-(correct|deplorable)$/);
                     if (match) {
                         const [, roomId, state] = match;
                         
                         if (!roomStates[roomId]) { // Ne pas √©craser si d√©j√† trouv√©
                             roomStates[roomId] = {
                                 state: state,
                                 comment: clickData?.comment || null,
                                 timestamp: clickData?.timestamp || new Date().toISOString(),
                                 photoUrls: clickData?.photoUrls || [],
                                 roomName: getPieceName(roomId),
                                 page: 'etat-initial'
                             };
                         }
                     }
                 });
             }
             
             console.log('üè† √âtats des pi√®ces finaux extraits:', roomStates);
             return roomStates;
         }
        
        function getPieceName(pieceId) {
            // Mapping des IDs vers des noms lisibles
            const pieceNames = {
                'chambre': 'Chambre',
                'cuisine': 'Cuisine',
                'salon': 'Salon',
                'salle-de-bain': 'Salle de Bain & Toilettes',
                'toilettes': 'Toilettes',
                'sdb': 'Salle de Bain',
                'entree': 'Entr√©e',
                'couloir': 'Couloir',
                'bureau': 'Bureau',
                'balcon': 'Balcon',
                'terrasse': 'Terrasse',
                // Gestion des IDs sp√©cifiques de votre syst√®me
                '1753358727481x453383598298510400': 'Chambre',
                '1753358727492x352542516437628540': 'Cuisine', 
                '1753358727506x824954939436015900': 'Salle de Bain & Toilettes',
                '1753358727515x999384935639220600': 'Salon'
            };
            
            // Si c'est un ID direct, utiliser le mapping
            if (pieceNames[pieceId]) {
                return pieceNames[pieceId];
            }
            
            // Si c'est un nom qui contient l'un des mots-cl√©s
            const pieceId_lower = pieceId.toLowerCase();
            if (pieceId_lower.includes('chambre')) return 'Chambre';
            if (pieceId_lower.includes('cuisine')) return 'Cuisine';
            if (pieceId_lower.includes('salon')) return 'Salon';
            if (pieceId_lower.includes('salle') || pieceId_lower.includes('toilette')) return 'Salle de Bain & Toilettes';
            if (pieceId_lower.includes('entree')) return 'Entr√©e';
            if (pieceId_lower.includes('couloir')) return 'Couloir';
            if (pieceId_lower.includes('bureau')) return 'Bureau';
            if (pieceId_lower.includes('balcon')) return 'Balcon';
            if (pieceId_lower.includes('terrasse')) return 'Terrasse';
            
            // Fallback: capitaliser la premi√®re lettre
            return pieceId.charAt(0).toUpperCase() + pieceId.slice(1);
        }
        
        function extractPieceIdFromPhoto(photo) {
            // Essayer d'extraire l'ID de pi√®ce depuis diff√©rents champs
            if (photo.pieceId) return photo.pieceId;
            if (photo.metadata?.pieceId) return photo.metadata.pieceId;
            
            // Extraire depuis storageKey: "uploaded_image_photo_xxxxx_9c0z2vqj1"
            if (photo.storageKey) {
                const taskMatch = photo.taskId?.match(/etat_initial_(.+)/);
                if (taskMatch) return taskMatch[1];
                
                // Autres patterns possibles
                const keyMatch = photo.storageKey.match(/uploaded_image_.*_([a-zA-Z-]+)_/);
                if (keyMatch) return keyMatch[1];
            }
            
            return 'unknown_piece';
        }
        
        function getSessionType(sessionData) {
            // D√©terminer le type de parcours/session
            
            console.log('üîç getSessionType - Analyse des donn√©es:', sessionData);
            
            // 1. V√©rifier les indicateurs explicites dans les m√©tadonn√©es
            if (sessionData.sessionType) {
                const type = sessionData.sessionType.toLowerCase();
                if (type.includes('menage')) return 'üßπ M√©nage';
                if (type.includes('voyage') || type.includes('voyageur')) return '‚úàÔ∏è Voyageur';
                return sessionData.sessionType;
            }
            
            if (sessionData.type) {
                const type = sessionData.type.toLowerCase();
                if (type.includes('menage')) return 'üßπ M√©nage';
                if (type.includes('voyage') || type.includes('voyageur')) return '‚úàÔ∏è Voyageur';
                return sessionData.type;
            }
            
            // 2. V√©rifier dans les donn√©es de parcours/flow
            if (sessionData.parcoursType) {
                const type = sessionData.parcoursType.toLowerCase();
                if (type.includes('menage')) return 'üßπ M√©nage';
                if (type.includes('voyage') || type.includes('voyageur')) return '‚úàÔ∏è Voyageur';
            }
            
            if (sessionData.flowType) {
                const type = sessionData.flowType.toLowerCase();
                if (type.includes('menage')) return 'üßπ M√©nage';
                if (type.includes('voyage') || type.includes('voyageur')) return '‚úàÔ∏è Voyageur';
            }
            
            // 3. Analyser les m√©tadonn√©es des interactions pour des indices
            if (sessionData.progress?.interactions?.buttonClicks) {
                const buttonMetadata = Object.values(sessionData.progress.interactions.buttonClicks).flat();
                
                for (let click of buttonMetadata) {
                    if (click.metadata) {
                        const metadataStr = JSON.stringify(click.metadata).toLowerCase();
                        if (metadataStr.includes('menage') || metadataStr.includes('cleaning')) {
                            return 'üßπ M√©nage';
                        }
                        if (metadataStr.includes('voyage') || metadataStr.includes('voyageur') || metadataStr.includes('traveler')) {
                            return '‚úàÔ∏è Voyageur';
                        }
                    }
                }
            }
            
            // 4. Analyser le user_id ou userId pour des patterns
            const userId = sessionData.user_id || sessionData.userId || '';
            if (userId) {
                // Si l'ID utilisateur contient des indices (selon votre syst√®me)
                const userStr = userId.toString().toLowerCase();
                // Vous pourriez avoir des patterns sp√©cifiques dans vos IDs
                console.log('üîç User ID analys√©:', userId);
            }
            
            // 5. Analyser les cl√©s g√©n√©rales pour d√©duire le type
            const sessionKeys = Object.keys(sessionData).join(' ').toLowerCase();
            console.log('üîç Cl√©s de session:', sessionKeys);
            
            if (sessionKeys.includes('menage') || sessionKeys.includes('cleaning') || sessionKeys.includes('housekeeping')) {
                return 'üßπ M√©nage';
            }
            
            if (sessionKeys.includes('voyage') || sessionKeys.includes('voyageur') || sessionKeys.includes('travel') || sessionKeys.includes('trip') || sessionKeys.includes('traveler')) {
                return '‚úàÔ∏è Voyageur';
            }
            
            // 6. Analyser le contexte des pi√®ces pour d√©duire le type
            const roomStates = extractRoomStatesFromSession(sessionData);
            const roomCount = Object.keys(roomStates).length;
            
            if (roomCount > 0) {
                // Si on a des contr√¥les de pi√®ces, c'est probablement un contr√¥le d'√©tat des lieux
                const hasComplexRooms = Object.keys(roomStates).some(roomId => 
                    roomId.includes('x') && roomId.length > 10 // IDs longs comme les v√¥tres
                );
                
                if (hasComplexRooms) {
                    // Avec vos IDs longs, essayer de d√©terminer le contexte
                    // Par d√©faut, consid√©rer comme un contr√¥le
                    return 'üè† Contr√¥le logement';
                }
            }
            
            // 7. V√©rifier dans les donn√©es d'origine du localStorage si accessible
            try {
                const checkSessions = JSON.parse(localStorage.getItem('checkeasy_check_sessions') || '{}');
                const sessionId = Object.keys(checkSessions).find(id => 
                    JSON.stringify(checkSessions[id]).includes(JSON.stringify(sessionData).substring(0, 100))
                );
                
                if (sessionId && checkSessions[sessionId]) {
                    const originalData = checkSessions[sessionId];
                    // Rechercher des indices dans les donn√©es compl√®tes
                    const fullDataStr = JSON.stringify(originalData).toLowerCase();
                    if (fullDataStr.includes('menage')) return 'üßπ M√©nage';
                    if (fullDataStr.includes('voyage') || fullDataStr.includes('voyageur')) return '‚úàÔ∏è Voyageur';
                }
            } catch (e) {
                console.log('Impossible d\'analyser les donn√©es d\'origine');
            }
            
            // Par d√©faut - essayer de d√©terminer selon le contexte
            if (roomCount > 0) {
                return 'üè† Contr√¥le';
            }
            
            return 'üìã Session';
        }
        
        function getSessionPhase(sessionData) {
            // D√©terminer la phase actuelle (checkin only, checkout only, ou checkin+checkout)
            
            const sessionStateInfo = determineSessionState(sessionData);
            const sessionState = sessionStateInfo.state;
            
            // Analyser les donn√©es pour voir ce qui a √©t√© fait
            const roomStates = extractRoomStatesFromSession(sessionData);
            const hasRoomStates = Object.keys(roomStates).length > 0;
            
            // V√©rifier les indicateurs de checkout
            const hasCheckoutData = Object.keys(sessionData).some(key => 
                key.toLowerCase().includes('checkout')
            );
            
            const hasCheckoutPhotos = Object.keys(sessionData).some(key => 
                key.includes('checkout') && key.includes('photo')
            );
            
            // D√©terminer la phase
            if (sessionState === 'checkout' || hasCheckoutPhotos) {
                return 'üîÑ CheckIn+CheckOut';
            } else if (hasRoomStates && !hasCheckoutData) {
                return 'üì• CheckIn seulement';
            } else if (hasCheckoutData) {
                return 'üì§ CheckOut seulement';
            } else {
                return 'üîÑ En cours';
            }
        }
        
        function determineSessionState(sessionData) {
            // M√©thodes pour d√©tecter l'√©tat de la session
            
            // 1. V√©rifier les indicateurs explicites
            if (sessionData.sessionState === 'checkout' || sessionData.state === 'checkout') {
                return { state: 'checkout', reason: 'Indicateur explicite: sessionState/state = checkout' };
            }
            
            if (sessionData.sessionState === 'checkin' || sessionData.state === 'checkin') {
                return { state: 'checkin', reason: 'Indicateur explicite: sessionState/state = checkin' };
            }
            
            // 2. Analyser le statut ou phase
            if (sessionData.status && sessionData.status.toLowerCase().includes('checkout')) {
                return { state: 'checkout', reason: 'Status contient "checkout"' };
            }
            
            if (sessionData.phase && sessionData.phase.toLowerCase().includes('checkout')) {
                return { state: 'checkout', reason: 'Phase contient "checkout"' };
            }
            
            // 3. V√©rifier les donn√©es de checkout pr√©sentes
            const hasCheckoutData = Object.keys(sessionData).some(key => 
                key.toLowerCase().includes('checkout') && sessionData[key] && 
                typeof sessionData[key] === 'object'
            );
            
            // 4. V√©rifier si toutes les pi√®ces ont un statut "completed" (indicateur potential de checkout)
            if (sessionData.pieces && Array.isArray(sessionData.pieces)) {
                const allCompleted = sessionData.pieces.every(piece => 
                    piece.status === 'completed' || piece.statut === 'completed' ||
                    piece.status === 'done' || piece.statut === 'done'
                );
                if (allCompleted && hasCheckoutData) {
                    return { state: 'checkout', reason: 'Toutes pi√®ces termin√©es + donn√©es checkout pr√©sentes' };
                }
            }
            
            // 5. Analyser la progression g√©n√©rale
            if (sessionData.progression && sessionData.progression >= 100 && hasCheckoutData) {
                return { state: 'checkout', reason: 'Progression 100% + donn√©es checkout pr√©sentes' };
            }
            
            // Par d√©faut, consid√©rer comme √©tant en checkin
            return { state: 'checkin', reason: 'Par d√©faut (aucun indicateur checkout d√©tect√©)' };
        }
        
        function isCheckinPhoto(photo, sessionData) {
            // Une photo est consid√©r√©e comme checkin si :
            
            // 1. Elle a des m√©tadonn√©es indiquant checkin
            if (photo.metadata && photo.metadata.type === 'checkin') {
                return true;
            }
            
            // 2. Elle ne contient pas d'indicateurs checkout
            if (photo.photoId && photo.photoId.toLowerCase().includes('checkout')) {
                return false;
            }
            
            if (photo.taskId && photo.taskId.toLowerCase().includes('checkout')) {
                return false;
            }
            
            // 3. Par d√©faut, les photos sont checkin si pas d'indicateur contraire
            return true;
        }
        
        function isCheckoutPhoto(photo, sessionData) {
            // Une photo est consid√©r√©e comme checkout si :
            
            // 1. Elle a des m√©tadonn√©es indiquant checkout
            if (photo.metadata && photo.metadata.type === 'checkout') {
                return true;
            }
            
            // 2. Son ID contient checkout
            if (photo.photoId && photo.photoId.toLowerCase().includes('checkout')) {
                return true;
            }
            
            // 3. Sa t√¢che est li√©e au checkout
            if (photo.taskId && photo.taskId.toLowerCase().includes('checkout')) {
                return true;
            }
            
            // 4. Elle a √©t√© prise apr√®s une certaine √©tape/temps
            // (cette logique pourrait √™tre affin√©e selon votre workflow)
            
            return false;
        }
        
        function testCheckoutStructure() {
            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('Veuillez s√©lectionner un CheckID', 'error');
                return;
            }
            
            const sessionData = checkIdData[selectedCheckId];
            console.log('üßπ TEST CHECKOUT STRUCTURE - Session data:', sessionData);
            
            // D√©terminer l'√©tat de la session
            const sessionStateInfo = determineSessionState(sessionData);
            console.log('üìç √âtat de la session d√©tect√©:', sessionStateInfo);
            
            // Extraire les pi√®ces avec la nouvelle logique checkout
            const piecesCheckout = extractPiecesProgressCheckout(sessionData);
            console.log('üè† Pi√®ces checkout extraites:', piecesCheckout);
            
            // Cr√©er la structure checkout compl√®te
            const checkoutTestData = {
                checkID: selectedCheckId,
                checkType: "checkout",
                logement_id: sessionData.logement_id || null,
                user_id: sessionData.user_id || sessionData.userId || null,
                timestamp: new Date().toISOString(),
                session_info: {
                    type: getSessionType(sessionData),
                    state: sessionStateInfo.state,
                    reason: sessionStateInfo.reason,
                    progression_globale: sessionData.progress?.progressPercentage || 0
                },
                statistiques_menage: {
                    pieces_totales: piecesCheckout.length,
                    taches_completees_total: sessionData.progress?.completedTaskIds?.length || 0,
                    photos_prises_total: sessionData.progress?.statistics?.totalPhotos || 0,
                    interactions_totales: Object.values(sessionData.progress?.pieceStates || {})
                        .reduce((sum, state) => sum + (state.totalInteractions || 0), 0)
                },
                pieces_menage: piecesCheckout
            };
            
            // Afficher le r√©sum√© visuel
            let summaryHtml = `
                <div class="alert info">
                    <h4>üßπ Test Structure Checkout - R√©sum√©</h4>
                    <div class="debug-summary">
                        <div><strong>CheckID:</strong> ${checkoutTestData.checkID}</div>
                        <div><strong>Type session:</strong> ${checkoutTestData.session_info.type}</div>
                        <div><strong>√âtat:</strong> ${checkoutTestData.session_info.state} (${checkoutTestData.session_info.reason})</div>
                        <div><strong>Logement:</strong> ${checkoutTestData.logement_id || 'Non d√©fini'}</div>
                        <div><strong>User:</strong> ${checkoutTestData.user_id || 'Non d√©fini'}</div>
                        <hr style="margin: 10px 0;">
                        <div><strong>Pi√®ces travaill√©es:</strong> ${checkoutTestData.statistiques_menage.pieces_totales}</div>
                        <div><strong>T√¢ches compl√©t√©es:</strong> ${checkoutTestData.statistiques_menage.taches_completees_total}</div>
                        <div><strong>Photos prises:</strong> ${checkoutTestData.statistiques_menage.photos_prises_total}</div>
                        <div><strong>Interactions totales:</strong> ${checkoutTestData.statistiques_menage.interactions_totales}</div>
                        <div><strong>Progression:</strong> ${checkoutTestData.session_info.progression_globale}%</div>
                    </div>
                </div>
            `;
            
            // D√©tailler par pi√®ce
            if (checkoutTestData.pieces_menage.length > 0) {
                summaryHtml += '<h4>üè† D√©tail par pi√®ce:</h4>';
                checkoutTestData.pieces_menage.forEach((p, index) => {
                    summaryHtml += `
                        <div class="piece-summary">
                            <strong>${p.piece.nom} (${p.piece.id.substring(0, 12)}...)</strong>
                            <div>‚Ä¢ <strong>Statut m√©nage:</strong> ${p.piece.statut_menage}</div>
                            <div>‚Ä¢ <strong>T√¢ches:</strong> ${p.resume.taches_completees}/${p.resume.taches_total} (${p.resume.progression_taches}%)</div>
                            <div>‚Ä¢ <strong>Photos prises:</strong> ${p.resume.photos_prises}</div>
                            <div>‚Ä¢ <strong>Photos r√©f√©rence:</strong> ${p.photos_reference ? '‚úÖ Oui' : '‚ùå Non'}</div>
                            <div>‚Ä¢ <strong>Interactions:</strong> ${p.resume.interactions_total}</div>
                        </div>
                    `;
                });
                
                // D√©tail des t√¢ches sp√©cifiques
                summaryHtml += '<h4>üìã T√¢ches d√©taill√©es:</h4>';
                checkoutTestData.pieces_menage.forEach(p => {
                    if (p.taches_menage.length > 0) {
                        summaryHtml += `<div class="piece-summary"><strong>${p.piece.nom}:</strong>`;
                        p.taches_menage.forEach(tache => {
                            const statusIcon = tache.statut === 'completed' ? '‚úÖ' : '‚è≥';
                            summaryHtml += `<div>  ${statusIcon} ${tache.nom}</div>`;
                        });
                        summaryHtml += '</div>';
                    }
                });
            }
            
            // Afficher la structure JSON compl√®te
            summaryHtml += `
                <h4>üîç Structure JSON checkout compl√®te:</h4>
                ${createEnhancedJsonViewer(checkoutTestData)}
            `;
            
            const debugElement = document.getElementById('debugSection');
            debugElement.style.display = 'block';
            debugElement.innerHTML = summaryHtml;
            
            // Log pour debug
            console.log('üßπ CHECKOUT TEST DATA FINAL:', checkoutTestData);
        }
        
        function debugUserExtraction() {
            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('S√©lectionnez un CheckID d\'abord', 'error');
                return;
            }
            
            console.log('üë§ DEBUG USER EXTRACTION - D√©but de l\'analyse');
            
            const sessionData = checkIdData[selectedCheckId];
            const userVerificationData = extractUserVerificationData(sessionData);
            
            // Analyser aussi les autres sources disponibles
            const debugInfo = {
                selectedCheckId: selectedCheckId,
                extractedUserData: userVerificationData,
                rawSessionData: {
                    userInfo: sessionData.userInfo || null,
                    user_id: sessionData.user_id || sessionData.userId || null,
                    userType: sessionData.userType || null
                },
                localStorageSources: {
                    userInfo: null,
                    registeredUsers: null
                }
            };
            
            // V√©rifier localStorage
            try {
                debugInfo.localStorageSources.userInfo = JSON.parse(localStorage.getItem('userInfo') || 'null');
            } catch (e) {
                debugInfo.localStorageSources.userInfo = 'ERREUR_PARSING';
            }
            
            try {
                const registered = JSON.parse(localStorage.getItem('registeredUsers') || '{}');
                debugInfo.localStorageSources.registeredUsers = {
                    count: Object.keys(registered).length,
                    users: registered
                };
            } catch (e) {
                debugInfo.localStorageSources.registeredUsers = 'ERREUR_PARSING';
            }
            
            // Afficher dans l'interface
            document.getElementById('debugSection').style.display = 'block';
            document.getElementById('debugContent').innerHTML = `
                <div style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 5px;">
                    <h4>üë§ Test Extraction Utilisateur</h4>
                    <div style="margin: 10px 0;">
                        <strong>CheckID:</strong> ${debugInfo.selectedCheckId}<br>
                        <strong>Status de v√©rification:</strong> <span style="color: ${userVerificationData.verification_status === 'verifie_session' ? '#28a745' : '#ffc107'}; font-weight: bold;">${userVerificationData.verification_status}</span><br>
                    </div>
                    
                    <div style="margin: 15px 0; padding: 10px; background: white; border-radius: 3px;">
                        <strong>üîç Utilisateur identifi√©:</strong><br>
                        ‚Ä¢ <strong>Pr√©nom:</strong> ${userVerificationData.user_info?.firstName || 'NON TROUV√â'}<br>
                        ‚Ä¢ <strong>Nom:</strong> ${userVerificationData.user_info?.lastName || 'NON TROUV√â'}<br>
                        ‚Ä¢ <strong>T√©l√©phone:</strong> ${userVerificationData.user_info?.phone || 'NON TROUV√â'}<br>
                        ‚Ä¢ <strong>Type:</strong> ${userVerificationData.user_info?.type_label || 'NON TROUV√â'}<br>
                        ‚Ä¢ <strong>Enregistr√© le:</strong> ${userVerificationData.user_info?.registeredAt ? new Date(userVerificationData.user_info.registeredAt).toLocaleString() : 'NON TROUV√â'}
                    </div>
                    
                    <div style="margin: 15px 0; padding: 10px; background: white; border-radius: 3px;">
                        <strong>üîó Infos de connexion:</strong><br>
                        ‚Ä¢ <strong>Session cr√©√©e:</strong> ${userVerificationData.connexion_info?.session_created ? new Date(userVerificationData.connexion_info.session_created).toLocaleString() : 'Inconnue'}<br>
                        ‚Ä¢ <strong>Dur√©e session:</strong> ${userVerificationData.connexion_info?.session_duration || 'Inconnue'}<br>
                        ‚Ä¢ <strong>Logement:</strong> ${userVerificationData.connexion_info?.logement_id || 'Non d√©fini'}<br>
                        ‚Ä¢ <strong>Type parcours:</strong> ${userVerificationData.connexion_info?.parcours_type || 'Inconnu'}
                    </div>
                    
                    <details style="margin-top: 20px;">
                        <summary style="cursor: pointer; font-weight: bold;">üìÑ Donn√©es compl√®tes</summary>
                        ${createEnhancedJsonViewer(debugInfo)}
                    </details>
                </div>
            `;
            
            console.log('üë§ DEBUG USER DATA COMPLET:', debugInfo);
            showAlert(`Utilisateur analys√©: ${userVerificationData.user_info?.firstName || 'Non trouv√©'} (${userVerificationData.verification_status})`, 'info');
        }
        
        function debugParcoursLogement() {
            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('S√©lectionnez un CheckID d\'abord', 'error');
                return;
            }
            
            console.log('üè† DEBUG PARCOURS/LOGEMENT - D√©but de l\'analyse');
            
            const sessionData = checkIdData[selectedCheckId];
            const parcoursLogementInfo = extractParcoursLogementInfo(sessionData);
            
            // Analyser aussi les autres sources disponibles
            const debugInfo = {
                selectedCheckId: selectedCheckId,
                extractedData: parcoursLogementInfo,
                rawSessionData: {
                    parcoursInfo: sessionData.parcoursInfo || null,
                    parcoursId: sessionData.parcoursId || null,
                    logement_id: sessionData.logement_id || null
                },
                urlParams: {},
                localStorageSources: {}
            };
            
            // V√©rifier URL params
            try {
                const urlParams = new URLSearchParams(window.location.search);
                debugInfo.urlParams = {
                    parcours: urlParams.get('parcours'),
                    checkid: urlParams.get('checkid'),
                    full_url: window.location.href
                };
            } catch (e) {
                debugInfo.urlParams = { error: e.message };
            }
            
            // V√©rifier localStorage
            ['current-parcours', 'parcours-data', 'logement-data'].forEach(key => {
                try {
                    const data = localStorage.getItem(key);
                    debugInfo.localStorageSources[key] = data ? JSON.parse(data) : null;
                } catch (e) {
                    debugInfo.localStorageSources[key] = 'ERREUR_PARSING';
                }
            });
            
            // Afficher dans l'interface
            document.getElementById('debugSection').style.display = 'block';
            document.getElementById('debugContent').innerHTML = `
                <div style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 5px;">
                    <h4>üè† Test Extraction Parcours/Logement</h4>
                    <div style="margin: 10px 0;">
                        <strong>CheckID:</strong> ${debugInfo.selectedCheckId}<br>
                        <strong>Source extraction:</strong> <span style="color: ${parcoursLogementInfo.extraction_source.includes('session') ? '#28a745' : '#ffc107'}; font-weight: bold;">${parcoursLogementInfo.extraction_source}</span><br>
                    </div>
                    
                    <div style="margin: 15px 0; padding: 10px; background: white; border-radius: 3px;">
                        <strong>üìã Parcours identifi√©:</strong><br>
                        ‚Ä¢ <strong>ID Parcours:</strong> ${parcoursLogementInfo.parcours_id || '‚ùå NON TROUV√â'}<br>
                        ‚Ä¢ <strong>Nom Parcours:</strong> ${parcoursLogementInfo.parcours_name || '‚ùå NON TROUV√â'}<br>
                    </div>
                    
                    <div style="margin: 15px 0; padding: 10px; background: white; border-radius: 3px;">
                        <strong>üè† Logement identifi√©:</strong><br>
                        ‚Ä¢ <strong>ID Logement:</strong> ${parcoursLogementInfo.logement_id || '‚ùå NON TROUV√â'}<br>
                        ‚Ä¢ <strong>Nom Logement:</strong> ${parcoursLogementInfo.logement_name || '‚ùå NON TROUV√â'}<br>
                    </div>
                    
                    <div style="margin: 15px 0; padding: 10px; background: white; border-radius: 3px;">
                        <strong>üîó Sources v√©rifi√©es:</strong><br>
                        ‚Ä¢ <strong>URL actuelle:</strong> ${debugInfo.urlParams.parcours ? '‚úÖ Parcours trouv√©' : '‚ùå Pas de param√®tre parcours'}<br>
                        ‚Ä¢ <strong>Session parcoursInfo:</strong> ${debugInfo.rawSessionData.parcoursInfo ? '‚úÖ Pr√©sent' : '‚ùå Absent'}<br>
                        ‚Ä¢ <strong>Session parcoursId:</strong> ${debugInfo.rawSessionData.parcoursId ? '‚úÖ Pr√©sent' : '‚ùå Absent'}<br>
                        ‚Ä¢ <strong>LocalStorage current-parcours:</strong> ${debugInfo.localStorageSources['current-parcours'] ? '‚úÖ Pr√©sent' : '‚ùå Absent'}
                    </div>
                    
                    <details style="margin-top: 20px;">
                        <summary style="cursor: pointer; font-weight: bold;">üìÑ Donn√©es compl√®tes</summary>
                        ${createEnhancedJsonViewer(debugInfo)}
                    </details>
                </div>
            `;
            
            console.log('üè† DEBUG PARCOURS/LOGEMENT COMPLET:', debugInfo);
            showAlert(`Parcours: ${parcoursLogementInfo.parcours_id || 'Non trouv√©'} | Logement: ${parcoursLogementInfo.logement_name || 'Non trouv√©'}`, 'info');
        }
        
        function debugEtapesDetails() {
            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('S√©lectionnez un CheckID d\'abord', 'error');
                return;
            }
            
            console.log('üéØ DEBUG √âTAPES D√âTAILS - D√©but de l\'analyse');
            
            const sessionData = checkIdData[selectedCheckId];
            
            // Tester avec les donn√©es CheckIn et CheckOut
            const piecesCheckin = extractRoomStatesFromSession(sessionData);
            const piecesCheckout = extractPiecesProgressCheckout(sessionData);
            
            const etapesCheckin = extractEtapesDetails(sessionData, piecesCheckin);
            const etapesCheckout = extractEtapesDetails(sessionData, piecesCheckout);
            
            // Analyser aussi les donn√©es brutes
            const debugInfo = {
                selectedCheckId: selectedCheckId,
                etapesCheckin: etapesCheckin,
                etapesCheckout: etapesCheckout,
                rawData: {
                    progress: sessionData.progress || null,
                    completedTaskIds: sessionData.progress?.completedTaskIds || null,
                    takenPhotos: sessionData.progress?.takenPhotos || null,
                    pieceStates: sessionData.progress?.pieceStates || null
                },
                extractedPieces: {
                    checkin: piecesCheckin,
                    checkout: piecesCheckout
                }
            };
            
            console.log('üéØ DEBUG √âTAPES COMPLET:', debugInfo);
            
            // Affichage dans une modal
            const modal = createModal('üéØ Debug √âtapes D√©tails', `
                <div style="font-family: monospace; font-size: 12px;">
                    <div style="margin: 15px 0;">
                        <h4>üìä Statistiques √âtapes CheckIn:</h4>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 3px; margin: 5px 0;">
                            <strong>Total √©tapes:</strong> ${etapesCheckin.statistiques.total_etapes}<br>
                            <strong>Compl√©t√©es:</strong> ${etapesCheckin.statistiques.etapes_completees_count}<br>
                            <strong>Avec photos:</strong> ${etapesCheckin.statistiques.etapes_avec_photos}<br>
                            <strong>Total photos:</strong> ${etapesCheckin.statistiques.total_photos}
                        </div>
                    </div>
                    
                    <div style="margin: 15px 0;">
                        <h4>üìä Statistiques √âtapes CheckOut:</h4>
                        <div style="background: #f8f9fa; padding: 10px; border-radius: 3px; margin: 5px 0;">
                            <strong>Total √©tapes:</strong> ${etapesCheckout.statistiques.total_etapes}<br>
                            <strong>Compl√©t√©es:</strong> ${etapesCheckout.statistiques.etapes_completees_count}<br>
                            <strong>Avec photos:</strong> ${etapesCheckout.statistiques.etapes_avec_photos}<br>
                            <strong>Total photos:</strong> ${etapesCheckout.statistiques.total_photos}
                        </div>
                    </div>
                    
                    <div style="margin: 15px 0;">
                        <h4>üéØ √âtapes Compl√©t√©es (CheckIn):</h4>
                        <div style="background: #e6ffe6; padding: 10px; border-radius: 3px; max-height: 200px; overflow-y: auto;">
                            ${etapesCheckin.etapes_completees.length > 0 
                                ? etapesCheckin.etapes_completees.map(etape => `
                                    <div style="margin: 5px 0; padding: 5px; background: white; border-radius: 2px;">
                                        <strong>ID:</strong> ${etape.etape_id}<br>
                                        <strong>Pi√®ce:</strong> ${etape.piece_name} (${etape.piece_id})<br>
                                        <strong>Type:</strong> ${etape.type} | <strong>Status:</strong> ${etape.status}
                                    </div>
                                `).join('')
                                : '<div style="color: #666;">Aucune √©tape compl√©t√©e trouv√©e</div>'
                            }
                        </div>
                    </div>
                    
                    <div style="margin: 15px 0;">
                        <h4>üì∏ Photos par √âtape (CheckOut):</h4>
                        <div style="background: #fff3e0; padding: 10px; border-radius: 3px; max-height: 200px; overflow-y: auto;">
                            ${Object.keys(etapesCheckout.photos_par_etape).length > 0
                                ? Object.entries(etapesCheckout.photos_par_etape).map(([etapeId, photos]) => `
                                    <div style="margin: 5px 0; padding: 5px; background: white; border-radius: 2px;">
                                        <strong>√âtape:</strong> ${etapeId}<br>
                                        <strong>Photos:</strong> ${photos.length} photo${photos.length > 1 ? 's' : ''}
                                        ${photos.map(photo => `
                                            <div style="margin-left: 15px; font-size: 11px;">
                                                ‚Ä¢ ${photo.photo_id} (${photo.uploaded ? 'Upload√©e' : 'Locale'})
                                            </div>
                                        `).join('')}
                                    </div>
                                `).join('')
                                : '<div style="color: #666;">Aucune photo par √©tape trouv√©e</div>'
                            }
                        </div>
                    </div>
                    
                    <div style="margin: 15px 0;">
                        <h4>üìã Donn√©es Brutes (Progress):</h4>
                        <div style="background: #f0f0f0; padding: 10px; border-radius: 3px; max-height: 300px; overflow-y: auto;">
                            <pre style="font-size: 10px; margin: 0;">${JSON.stringify(debugInfo.rawData, null, 2)}</pre>
                        </div>
                    </div>
                </div>
            `);
            
            showAlert('üéØ Debug √©tapes affich√© dans la modal', 'info');
        }
        
        function testEtapeIdCleaning() {
            console.log('üßπ TEST NETTOYAGE ETAPE ID');
            
            const testIds = [
                'etat-initial-1753358727481x453383598298510400-correct',
                '1758613144699x173912139510638200',
                'photo-task-1759000000000x123456789012345678-validate',
                'simple-1234567890123x987654321098765432',
                'invalid-id-without-pattern',
                '1111111111111x222222222222222222'
            ];
            
            function cleanEtapeId(etapeId) {
                if (!etapeId) return undefined;
                const etapeIdMatch = etapeId.match(/(\d+x\d+)/);
                return etapeIdMatch ? etapeIdMatch[1] : etapeId;
            }
            
            const results = testIds.map(id => ({
                original: id,
                cleaned: cleanEtapeId(id),
                isValid: /^\d+x\d+$/.test(cleanEtapeId(id))
            }));
            
            console.table(results);
            
            // Afficher dans une modal
            const modal = createModal('üßπ Test Nettoyage EtapeId', `
                <div style="font-family: monospace; font-size: 12px;">
                    <div style="margin: 15px 0;">
                        <h4>üéØ R√©sultats du nettoyage :</h4>
                        ${results.map(result => `
                            <div style="margin: 10px 0; padding: 10px; background: ${result.isValid ? '#e6ffe6' : '#ffe6e6'}; border-radius: 3px;">
                                <div><strong>Original :</strong> <code>${result.original}</code></div>
                                <div><strong>Nettoy√© :</strong> <code>${result.cleaned}</code></div>
                                <div><strong>Valide :</strong> ${result.isValid ? '‚úÖ Oui' : '‚ùå Non'}</div>
                            </div>
                        `).join('')}
                    </div>
                    <div style="margin: 15px 0; padding: 10px; background: #f0f0f0; border-radius: 3px;">
                        <h4>üìã Pattern de validation :</h4>
                        <code>/^\\d+x\\d+$/</code><br>
                        <small>Doit √™tre au format : chiffres + 'x' + chiffres</small>
                    </div>
                </div>
            `);
            
            showAlert('üßπ Test de nettoyage affich√© dans la modal', 'info');
        }
        
        async function fetchParcoursData() {
            console.log('üîç R√âCUP√âRATION DONN√âES PARCOURS');
            
            // Utiliser l'endpoint sp√©cifique avec le param√®tre parcours
            const parcoursId = '1758613142823x462099088965380700';
            const parcourTestUrl = `https://checkeasy-57905.bubbleapps.io/version-test/api/1.1/wf/endpointPiece?parcours=${parcoursId}`;
            
            try {
                showAlert('üì° R√©cup√©ration des donn√©es parcours...', 'info');
                
                const response = await fetch(parcourTestUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const parcoursData = await response.json();
                
                console.log('‚úÖ Donn√©es parcours r√©cup√©r√©es:', parcoursData);
                
                // Analyser la structure pour identifier les relations piece/etape
                const analysisResult = analyzeParcoursStructure(parcoursData);
                
                // Afficher dans une modal
                const modal = createModal('üîç Structure des Donn√©es Parcours', `
                    <div style="font-family: monospace; font-size: 12px; max-height: 500px; overflow-y: auto;">
                        <div style="margin: 15px 0;">
                            <h4>üìä Analyse des Relations Piece/Etape:</h4>
                            ${analysisResult.summary}
                        </div>
                        
                        <div style="margin: 15px 0;">
                            <h4>üéØ Premier Parcours (exemple):</h4>
                            <div style="background: #f0f0f0; padding: 10px; border-radius: 3px;">
                                <pre style="margin: 0; font-size: 10px;">${JSON.stringify(parcoursData.response?.results?.[0] || parcoursData, null, 2)}</pre>
                            </div>
                        </div>
                        
                        <div style="margin: 15px 0;">
                            <h4>üìã Probl√®me Identifi√©:</h4>
                            ${analysisResult.problemAnalysis}
                        </div>
                    </div>
                `);
                
                showAlert('‚úÖ Donn√©es parcours analys√©es - voir modal', 'success');
                
            } catch (error) {
                console.error('‚ùå Erreur r√©cup√©ration parcours:', error);
                showAlert(`‚ùå Erreur: ${error.message}`, 'error');
                
                // Fallback: utiliser les donn√©es locales si disponibles
                if (typeof Data !== 'undefined') {
                    console.log('üìã Utilisation des donn√©es locales comme fallback');
                    const localAnalysis = analyzeParcoursStructure({ response: { results: [Data] } });
                    
                    const modal = createModal('üîç Analyse Donn√©es Locales (Fallback)', `
                        <div style="font-family: monospace; font-size: 12px; max-height: 500px; overflow-y: auto;">
                            <div style="margin: 15px 0;">
                                <h4>üìä Analyse depuis donn√©es locales:</h4>
                                ${localAnalysis.summary}
                            </div>
                            
                            <div style="margin: 15px 0;">
                                <h4>üìã Probl√®me Identifi√©:</h4>
                                ${localAnalysis.problemAnalysis}
                            </div>
                        </div>
                    `);
                    
                    showAlert('‚ö†Ô∏è Erreur API - analyse des donn√©es locales affich√©e', 'warning');
                }
            }
        }
        
        function analyzeParcoursStructure(data) {
            let summary = '<div style="color: #666;">Aucune donn√©e √† analyser</div>';
            let problemAnalysis = '<div style="color: #666;">Pas d\'analyse possible</div>';
            
            try {
                console.log('üîç Donn√©es re√ßues pour analyse:', data);
                
                // Adapter selon la structure de l'endpoint endpointPiece
                const parcours = data?.response?.results?.[0] || data?.response || data;
                
                if (parcours?.piece && Array.isArray(parcours.piece)) {
                    let pieceEtapeRelations = [];
                    let duplicateIds = [];
                    
                    parcours.piece.forEach(piece => {
                        const pieceId = piece.pieceID;
                        const pieceName = piece.nom;
                        
                        console.log('üîç Analyse pi√®ce:', { pieceId, pieceName, hasEtapes: !!piece.etapes, etapesCount: piece.etapes?.length });
                        
                        if (piece.etapes && Array.isArray(piece.etapes)) {
                            piece.etapes.forEach((etape, index) => {
                                const etapeId = etape.etapeID;
                                
                                console.log('üéØ Analyse √©tape:', { 
                                    index, 
                                    etapeId, 
                                    pieceId, 
                                    hasEtapeId: !!etapeId,
                                    sameAsPiece: etapeId === pieceId,
                                    isTodo: etape.isTodo,
                                    hasImage: !!etape.image
                                });
                                
                                const relation = {
                                    pieceId: pieceId,
                                    pieceName: pieceName,
                                    etapeId: etapeId,
                                    etapeIndex: index,
                                    isTodo: etape.isTodo,
                                    hasImage: !!etape.image,
                                    sameId: pieceId === etapeId,
                                    etapeValid: !!etapeId && /^\d+x\d+$/.test(etapeId)
                                };
                                
                                pieceEtapeRelations.push(relation);
                                
                                if (pieceId === etapeId) {
                                    duplicateIds.push(relation);
                                } else if (!etapeId) {
                                    duplicateIds.push({...relation, reason: 'missing_etapeId'});
                                }
                            });
                        }
                    });
                    
                    summary = `
                        <div style="margin: 10px 0;">
                            <strong>Total pi√®ces:</strong> ${parcours.piece.length}<br>
                            <strong>Total relations piece/etape:</strong> ${pieceEtapeRelations.length}<br>
                            <strong>IDs identiques (probl√©matiques):</strong> ${duplicateIds.length}
                        </div>
                        
                        ${duplicateIds.length > 0 ? `
                            <div style="background: #ffe6e6; padding: 10px; border-radius: 3px; margin: 10px 0;">
                                <strong>‚ö†Ô∏è Probl√®me d√©tect√©:</strong><br>
                                ${duplicateIds.map(dup => `
                                    <div style="margin: 5px 0;">
                                        ‚Ä¢ Pi√®ce "${dup.pieceName}" : pieceID = etapeID = "${dup.pieceId}"
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        <div style="background: #e6ffe6; padding: 10px; border-radius: 3px; margin: 10px 0;">
                            <strong>‚úÖ Relations correctes:</strong><br>
                            ${pieceEtapeRelations.filter(rel => !rel.sameId && rel.etapeValid).map(rel => `
                                <div style="margin: 3px 0; font-size: 11px;">
                                    ‚Ä¢ ${rel.pieceName}[${rel.etapeIndex}]: piece="${rel.pieceId.substring(0, 13)}..." ‚â† etape="${rel.etapeId.substring(0, 13)}..." ${rel.isTodo ? 'üìã' : 'üì∏'}
                                </div>
                            `).join('') || '<div>Aucune relation correcte trouv√©e</div>'}
                        </div>
                        
                        <div style="background: #fff3cd; padding: 10px; border-radius: 3px; margin: 10px 0;">
                            <strong>üìä Statistiques d√©taill√©es:</strong><br>
                            ‚Ä¢ √âtapes avec images: ${pieceEtapeRelations.filter(rel => rel.hasImage).length}<br>
                            ‚Ä¢ √âtapes todos: ${pieceEtapeRelations.filter(rel => rel.isTodo).length}<br>
                            ‚Ä¢ EtapeID valides: ${pieceEtapeRelations.filter(rel => rel.etapeValid).length}<br>
                            ‚Ä¢ EtapeID uniques: ${new Set(pieceEtapeRelations.map(rel => rel.etapeId).filter(id => id)).size}
                        </div>
                    `;
                    
                    problemAnalysis = duplicateIds.length > 0 
                        ? `<div style="color: #d63384; font-weight: bold;">
                            üö® PROBL√àME CONFIRM√â: ${duplicateIds.length} √©tape(s) ont le m√™me ID que leur pi√®ce parente.
                            <br><br>
                            <strong>Solution:</strong> Les etapeID doivent √™tre uniques et diff√©rents des pieceID.
                            <br>
                            <strong>Impact:</strong> Cela peut causer des conflits dans le tracking des interactions.
                           </div>`
                        : `<div style="color: #198754; font-weight: bold;">
                            ‚úÖ Pas de probl√®me d√©tect√© - tous les etapeID sont diff√©rents des pieceID.
                           </div>`;
                }
                
            } catch (error) {
                summary = `<div style="color: #d63384;">Erreur analyse: ${error.message}</div>`;
                problemAnalysis = `<div style="color: #d63384;">Impossible d'analyser la structure</div>`;
            }
            
            return { summary, problemAnalysis };
        }
        
        function testEtapeIdGeneration() {
            console.log('üîÑ TEST G√âN√âRATION ETAPE ID');
            
            const testCases = [
                { rawEtapeId: undefined, pieceId: '1754248719205x263213672705941760', etapeIndex: 0, scenario: 'EtapeId manquant' },
                { rawEtapeId: null, pieceId: '1754248719205x354889845660652600', etapeIndex: 1, scenario: 'EtapeId null' },
                { rawEtapeId: '1754248719205x263213672705941760', pieceId: '1754248719205x263213672705941760', etapeIndex: 0, scenario: 'EtapeId = PieceId (dupliqu√©)' },
                { rawEtapeId: '1758613144699x173912139510638200', pieceId: '1758613142342x317402074465620540', etapeIndex: 0, scenario: 'EtapeId diff√©rent et valide' },
                { rawEtapeId: 'etat-initial-1753358727481x453383598298510400-correct', pieceId: '1754248719205x263213672705941760', etapeIndex: 2, scenario: 'EtapeId avec pr√©fixe/suffixe' }
            ];
            
            function ensureUniqueEtapeId(rawEtapeId, pieceId, etapeIndex = 0) {
                // Si pas d'etapeId ou si etapeId = pieceId, g√©n√©rer un ID unique
                if (!rawEtapeId || rawEtapeId === pieceId) {
                    const timestamp = Date.now() + etapeIndex; // Ajouter l'index pour √©viter les doublons
                    const randomSuffix = Math.floor(Math.random() * 1000000000000000000);
                    const generatedId = `${timestamp}x${randomSuffix}`;
                    return generatedId;
                }
                
                // Si etapeId existe et est diff√©rent du pieceId, le nettoyer normalement
                const etapeIdMatch = rawEtapeId.match(/(\d+x\d+)/);
                return etapeIdMatch ? etapeIdMatch[1] : rawEtapeId;
            }
            
            const results = testCases.map(testCase => {
                const generatedId = ensureUniqueEtapeId(testCase.rawEtapeId, testCase.pieceId, testCase.etapeIndex);
                return {
                    scenario: testCase.scenario,
                    original: testCase.rawEtapeId || 'undefined',
                    pieceId: testCase.pieceId,
                    generated: generatedId,
                    isUnique: generatedId !== testCase.pieceId,
                    isValid: /^\d+x\d+$/.test(generatedId)
                };
            });
            
            console.table(results);
            
            // Afficher dans une modal
            const modal = createModal('üîÑ Test G√©n√©ration EtapeId', `
                <div style="font-family: monospace; font-size: 12px;">
                    <div style="margin: 15px 0;">
                        <h4>üéØ R√©sultats de la g√©n√©ration automatique :</h4>
                        ${results.map(result => `
                            <div style="margin: 10px 0; padding: 10px; background: ${result.isValid && result.isUnique ? '#e6ffe6' : '#ffe6e6'}; border-radius: 3px;">
                                <div><strong>Sc√©nario :</strong> ${result.scenario}</div>
                                <div><strong>Original :</strong> <code>${result.original}</code></div>
                                <div><strong>PieceId :</strong> <code>${result.pieceId}</code></div>
                                <div><strong>G√©n√©r√© :</strong> <code>${result.generated}</code></div>
                                <div><strong>Unique :</strong> ${result.isUnique ? '‚úÖ Oui' : '‚ùå Non'}</div>
                                <div><strong>Valide :</strong> ${result.isValid ? '‚úÖ Oui' : '‚ùå Non'}</div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="margin: 15px 0; padding: 10px; background: #f0f0f0; border-radius: 3px;">
                        <h4>üí° Solution impl√©ment√©e :</h4>
                        <ul style="margin: 5px 0; padding-left: 20px;">
                            <li><strong>Si etapeId manquant :</strong> G√©n√©ration automatique au format timestampXrandom</li>
                            <li><strong>Si etapeId = pieceId :</strong> G√©n√©ration automatique pour √©viter les conflits</li>
                            <li><strong>Si etapeId valide :</strong> Nettoyage du format (suppression pr√©fixes/suffixes)</li>
                            <li><strong>Unicit√© garantie :</strong> Timestamp + random + index pour √©viter doublons</li>
                        </ul>
                    </div>
                </div>
            `);
            
            showAlert('üîÑ Test de g√©n√©ration affich√© dans la modal', 'info');
        }
        
        function debugSessionState() {
            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('S√©lectionnez un CheckID d\'abord', 'error');
                return;
            }
            
            const sessionData = checkIdData[selectedCheckId];
            const sessionStateInfo = determineSessionState(sessionData);
            
            console.log('üîç DEBUG SESSION STATE - CheckID:', selectedCheckId);
            console.log('üîç √âtat d√©tect√©:', sessionStateInfo);
            console.log('üîç Donn√©es de session:', sessionData);
            
            const debugInfo = {
                checkId: selectedCheckId,
                sessionState: sessionStateInfo,
                sessionKeys: Object.keys(sessionData),
                sessionStatus: sessionData.status,
                sessionPhase: sessionData.phase,
                sessionProgression: sessionData.progression,
                pieceCount: sessionData.pieces ? sessionData.pieces.length : 0,
                hasCheckoutKeys: Object.keys(sessionData).filter(key => key.toLowerCase().includes('checkout'))
            };
            
            // Test des deux g√©n√©rations
            const checkinPieces = extractPiecesProgress(sessionData, 'checkin');
            const checkoutPieces = extractPiecesProgress(sessionData, 'checkout');
            
            debugInfo.checkinPiecesCount = checkinPieces.length;
            debugInfo.checkoutPiecesCount = checkoutPieces.length;
            debugInfo.checkoutShouldBeEmpty = sessionStateInfo.state !== 'checkout';
            
            // Afficher dans la section debug
            document.getElementById('debugSection').style.display = 'block';
            document.getElementById('debugContent').innerHTML = `
                <div style="font-family: monospace; background: #f8f9fa; padding: 15px; border-radius: 5px;">
                    <h4>üîç Test √âtat de Session</h4>
                    <div style="margin: 10px 0;">
                        <strong>CheckID:</strong> ${debugInfo.checkId}<br>
                        <strong>√âtat d√©tect√©:</strong> <span style="color: ${sessionStateInfo.state === 'checkout' ? '#dc3545' : '#28a745'}; font-weight: bold;">${sessionStateInfo.state}</span><br>
                        <strong>Raison:</strong> ${sessionStateInfo.reason}<br>
                    </div>
                    <div style="margin: 15px 0;">
                        <strong>G√©n√©ration des pi√®ces:</strong><br>
                        ‚Ä¢ CheckIn: ${debugInfo.checkinPiecesCount} pi√®ce(s)<br>
                        ‚Ä¢ CheckOut: ${debugInfo.checkoutPiecesCount} pi√®ce(s) ${debugInfo.checkoutShouldBeEmpty ? '(devrait √™tre 0 ‚úÖ)' : '(normal pour checkout)'}<br>
                    </div>
                    <div style="margin: 15px 0;">
                        <strong>Cl√©s de session contenant "checkout":</strong><br>
                        ${debugInfo.hasCheckoutKeys.length > 0 ? debugInfo.hasCheckoutKeys.join(', ') : 'Aucune'}
                    </div>
                    ${createEnhancedJsonViewer(debugInfo)}
                </div>
            `;
            
            showAlert(`√âtat: ${sessionStateInfo.state} - ${debugInfo.checkoutPiecesCount === 0 && sessionStateInfo.state === 'checkin' ? 'Correction OK ‚úÖ' : '√Ä v√©rifier'}`, 
                     debugInfo.checkoutPiecesCount === 0 && sessionStateInfo.state === 'checkin' ? 'success' : 'info');
        }
        
        function testNewDataStructure() {
            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('S√©lectionnez un CheckID d\'abord', 'error');
                return;
            }
            
            const sessionData = checkIdData[selectedCheckId];
            
            // Test de l'extraction des √©tats des pi√®ces
            const roomStates = extractRoomStatesFromSession(sessionData);
            const pieces = extractPiecesProgress(sessionData, 'checkin');
            
            console.log('üè† √âtats des pi√®ces extraits:', roomStates);
            console.log('üìä Pi√®ces g√©n√©r√©es:', pieces);
            
            // Cr√©ation d'un JSON structur√© et lisible
            const structuredData = {
                checkID: selectedCheckId,
                logement_id: sessionData.logement_id || null,
                user_id: sessionData.user_id || sessionData.userId || null,
                timestamp: new Date().toISOString(),
                session_state: determineSessionState(sessionData),
                pieces_analysees: pieces.map(piece => ({
                    piece: {
                        id: piece.piece_id,
                        nom: piece.nom,
                        etat_utilisateur: piece.etat_utilisateur || 'non_d√©fini',
                        statut_validation: piece.statut_validation || 'en_attente'
                    },
                    commentaire: piece.commentaire,
                    photos: piece.photos?.map(photo => ({
                        url: photo.url,
                        timestamp: photo.timestamp,
                        type: photo.type
                    })) || [],
                    timestamp_validation: piece.timestamp
                }))
            };
            
            // Afficher dans la section debug
            document.getElementById('debugSection').style.display = 'block';
            document.getElementById('debugContent').innerHTML = `
                <div style="font-family: monospace;">
                    <h4>üè† Nouvelle Structure des Donn√©es</h4>
                    <div style="background: #e8f5e8; padding: 15px; border-radius: 5px; margin: 15px 0;">
                        <strong>‚úÖ Structure am√©lior√©e:</strong><br>
                        ‚Ä¢ ${pieces.length} pi√®ce(s) d√©tect√©e(s)<br>
                        ‚Ä¢ ${pieces.filter(p => p.commentaire).length} pi√®ce(s) avec commentaires<br>
                        ‚Ä¢ ${pieces.reduce((total, p) => total + (p.photos?.length || 0), 0)} photo(s) total<br>
                        ‚Ä¢ Hi√©rarchie: CheckID ‚Üí Pi√®ces ‚Üí √âtat + Commentaire + Photos
                    </div>
                    
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 5px; max-height: 400px; overflow-y: auto;">
                        <strong>üìã Aper√ßu des pi√®ces:</strong><br><br>
                        ${pieces.map(piece => `
                            <div style="margin: 10px 0; padding: 10px; border-left: 3px solid ${piece.etat_utilisateur === 'correct' ? '#28a745' : piece.etat_utilisateur === 'deplorable' ? '#dc3545' : '#ffc107'}; background: white;">
                                <strong>${piece.nom}</strong> (${piece.piece_id})<br>
                                √âtat: <span style="color: ${piece.etat_utilisateur === 'correct' ? '#28a745' : piece.etat_utilisateur === 'deplorable' ? '#dc3545' : '#ffc107'}; font-weight: bold;">${piece.etat_utilisateur || 'non_d√©fini'}</span><br>
                                ${piece.commentaire ? `Commentaire: "${piece.commentaire}"<br>` : 'Pas de commentaire<br>'}
                                Photos: ${piece.photos?.length || 0} image(s)
                            </div>
                        `).join('')}
                    </div>
                    
                    <details style="margin-top: 20px;">
                        <summary style="cursor: pointer; font-weight: bold;">üìÑ JSON Complet</summary>
                        ${createEnhancedJsonViewer(structuredData)}
                    </details>
                </div>
            `;
            
            showAlert(`Structure test√©e: ${pieces.length} pi√®ce(s) trouv√©e(s) !`, 'success');
        }
        
        /**
         * üéØ WEBHOOK UNIFI√â - Envoie TOUT (checkin + checkout) en une seule fois
         * Utilise la M√äME fonction que le webhook checkin qui fonctionnait
         */
        async function sendUnifiedWebhook() {
            console.log('=== üéØ DEBUT sendUnifiedWebhook ===');

            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('Veuillez d\'abord s√©lectionner un CheckID', 'error');
                return;
            }

            try {
                const sessionData = checkIdData[selectedCheckId];

                // Construire l'URL depuis la configuration
                const unifiedUrl = buildWebhookUrl('unified');

                console.log('üîó Endpoint UNIFI√â utilis√©:', unifiedUrl);
                console.log('üîó Configuration actuelle:', {
                    environment: webhookConfig.environment,
                    includeInitialize: webhookConfig.includeInitialize
                });

                showAlert('üîÑ G√©n√©ration des donn√©es compl√®tes (CHECKIN + CHECKOUT)...', 'info');

                // üéØ UTILISER LA M√äME FONCTION QUI FONCTIONNE POUR LE CHECKIN
                const unifiedData = generateWebhookData(sessionData, 'unified');

                console.log('üì¶ Donn√©es UNIFI√âES g√©n√©r√©es:', unifiedData);

                addWebhookLog(`üöÄ Envoi webhook UNIFI√â vers ${unifiedUrl}...`, 'pending');

                // Envoyer les donn√©es
                const response = await fetch(unifiedUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(unifiedData)
                });

                const responseData = await response.json();

                if (response.ok) {
                    const dataId = unifiedData.checkID || unifiedData.parcours?.id || 'unknown';
                    addWebhookLog(`‚úÖ Webhook UNIFI√â envoy√© avec succ√®s (${response.status}) - ID: ${dataId}`, 'success', responseData);
                    showAlert(`‚úÖ Webhook UNIFI√â envoy√© avec succ√®s! (ID: ${dataId})`, 'success');
                } else {
                    throw new Error(`HTTP ${response.status}: ${responseData.message || 'Erreur inconnue'}`);
                }

            } catch (error) {
                console.error('‚ùå Erreur webhook UNIFI√â:', error);
                addWebhookLog(`‚ùå Erreur envoi webhook UNIFI√â: ${error.message}`, 'error', { error: error.message });
                showAlert(`‚ùå Erreur envoi webhook UNIFI√â: ${error.message}`, 'error');
            }
        }

        async function sendWebhook(type) {
            console.log('=== üöÄ DEBUT sendWebhook ===');
            console.log('üìç Type demand√©:', type);
            console.log('üìç selectedCheckId:', selectedCheckId);
            console.log('üìç checkIdData disponible:', !!checkIdData);
            console.log('üìç checkinDataGenerated:', checkinDataGenerated);
            console.log('üìç checkoutDataGenerated:', checkoutDataGenerated);
            
            // V√©rifier l'√©tat du bouton
            const btn = document.getElementById(type === 'checkin' ? 'sendCheckinBtn' : 'sendCheckoutBtn');
            console.log('üìç Bouton trouv√©:', !!btn, 'disabled:', btn?.disabled);
            
            // V√©rifier les variables globales
            console.log('üìç Variables globales:');
            console.log('  - window.selectedCheckId:', window.selectedCheckId);
            console.log('  - window.checkIdData:', !!window.checkIdData);
            console.log('  - window.checkinDataGenerated:', !!window.checkinDataGenerated);
            
            // Alerter visuellement
            showAlert(`üîÑ Fonction sendWebhook(${type}) appel√©e!`, 'info');
            
            let data = type === 'checkin' ? checkinDataGenerated : checkoutDataGenerated;
            
            if (!data) {
                console.log('‚ùå Aucune donn√©e trouv√©e pour:', type);
                
                // Auto-g√©n√©ration des donn√©es si pas encore fait
                if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                    showAlert('Veuillez d\'abord s√©lectionner un CheckID', 'error');
                    return;
                }
                
                showAlert(`üîÑ G√©n√©ration automatique des donn√©es ${type}...`, 'info');
                
                try {
                    if (type === 'checkin') {
                        generateCheckinData();
                        data = checkinDataGenerated;
                    } else {
                        generateCheckoutData();
                        data = checkoutDataGenerated;
                    }
                    
                    if (!data) {
                        showAlert(`√âchec de la g√©n√©ration automatique ${type}`, 'error');
                        return;
                    }
                    
                    showAlert(`‚úÖ Donn√©es ${type} g√©n√©r√©es automatiquement`, 'success');
                } catch (error) {
                    console.error('Erreur g√©n√©ration auto:', error);
                    showAlert(`Erreur g√©n√©ration ${type}: ${error.message}`, 'error');
                    return;
                }
            }
            
            console.log('üì§ Donn√©es √† envoyer:', data);
            
            // Utiliser la configuration pour construire l'endpoint
            const endpoint = buildWebhookUrl(type);
            console.log('üîó Endpoint utilis√© pour', type.toUpperCase() + ':', endpoint);
            console.log('üîó Configuration actuelle:', {
                environment: webhookConfig.environment,
                includeInitialize: webhookConfig.includeInitialize,
                type: type
            });
            
            // Afficher le statut d'envoi
            console.log('üìù Ajout du log...');
            const dataId = data.checkID || data.parcours?.id || 'unknown';
            addWebhookLog(`üöÄ Envoi ${type} vers Bubble (ID: ${dataId})...`, 'pending');
            showAlert(`üöÄ D√©but envoi ${type} (ID: ${dataId.substring(0, 20)}...)`, 'info');
            
            try {
                console.log('üåê D√©marrage fetch vers:', endpoint);
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify(data)
                });
                
                console.log('üì° R√©ponse re√ßue:', response.status);
                const responseData = await response.json();
                console.log('üìÑ Donn√©es de r√©ponse:', responseData);
                
                if (response.ok) {
                    addWebhookLog(`‚úÖ ${type} envoy√© avec succ√®s (${response.status}) - ID: ${dataId}`, 'success', responseData);
                    showAlert(`Webhook ${type} envoy√© avec succ√®s! (ID: ${dataId.substring(0, 20)}...)`, 'success');
                } else {
                    throw new Error(`HTTP ${response.status}: ${responseData.message || 'Erreur inconnue'}`);
                }
                
            } catch (error) {
                console.error('‚ùå Erreur compl√®te:', error);
                addWebhookLog(`‚ùå Erreur envoi ${type}: ${error.message}`, 'error', { error: error.message });
                showAlert(`Erreur envoi ${type}: ${error.message}`, 'error');
            }
        }
        
        function addWebhookLog(message, status, data = null) {
            const logsContainer = document.getElementById('webhookLogs');
            
            if (logsContainer.textContent === 'Aucun envoi effectu√©') {
                logsContainer.innerHTML = '';
            }
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${status}`;
            
            let logContent = `
                <div class="log-timestamp">${new Date().toLocaleString()}</div>
                <div>${message}</div>
            `;
            
            if (data) {
                logContent += `<div class="json-preview">${createEnhancedJsonViewer(data)}</div>`;
            }
            
            logEntry.innerHTML = logContent;
            logsContainer.insertBefore(logEntry, logsContainer.firstChild);
            
            // Limiter √† 10 logs max
            while (logsContainer.children.length > 10) {
                logsContainer.removeChild(logsContainer.lastChild);
            }
        }
        
        // === PARCOURS ===
        async function refreshParcours() {
            const container = document.getElementById('parcoursContent');
            container.innerHTML = '<div class="loading"></div> Chargement des parcours...';
            
            try {
                // 1. Parcours depuis IndexedDB
                const parcoursFromDB = await loadParcoursFromIndexedDB();
                
                // 2. Sessions de contr√¥le depuis localStorage
                const sessions = getCheckSessions();
                
                // 3. Donn√©es app-flow-state
                const appFlowState = getAppFlowState();
                
                // 4. Mise √† jour des stats
                document.getElementById('parcoursCount').textContent = parcoursFromDB.length;
                document.getElementById('sessionsCount').textContent = Object.keys(sessions).length;
                document.getElementById('progressCount').textContent = appFlowState ? '1' : '0';
                
                // 5. Affichage
                displayParcours(parcoursFromDB, sessions, appFlowState);
                
            } catch (error) {
                container.innerHTML = `<div class="alert error">Erreur: ${error.message}</div>`;
                console.error('Erreur refresh parcours:', error);
            }
        }
        
         async function loadParcoursFromIndexedDB() {
             return new Promise((resolve, reject) => {
                 const request = indexedDB.open('CheckEasyCache', 2);
                 
                 request.onerror = () => {
                     console.warn('Impossible d\'ouvrir IndexedDB');
                     resolve([]); // Ne pas rejeter, juste retourner un array vide
                 };
                 
                 request.onsuccess = (event) => {
                     const db = event.target.result;
                     
                     try {
                         // V√©rifier quels object stores existent
                         console.log('Object stores disponibles:', Array.from(db.objectStoreNames));
                         
                         if (!db.objectStoreNames.contains('parcours')) {
                             console.log('Object store "parcours" non trouv√©');
                             db.close();
                             resolve([]);
                             return;
                         }
                         
                         const transaction = db.transaction(['parcours'], 'readonly');
                         
                         transaction.onerror = () => {
                             console.error('Erreur transaction parcours');
                             db.close();
                             resolve([]);
                         };
                         
                         const store = transaction.objectStore('parcours');
                         const getAllRequest = store.getAll();
                         
                         getAllRequest.onsuccess = () => {
                             const result = getAllRequest.result || [];
                             console.log('Parcours charg√©s depuis IndexedDB:', result.length);
                             db.close();
                             resolve(result);
                         };
                         
                         getAllRequest.onerror = () => {
                             console.error('Erreur lecture parcours');
                             db.close();
                             resolve([]);
                         };
                         
                     } catch (error) {
                         console.error('Erreur dans loadParcoursFromIndexedDB:', error);
                         db.close();
                         resolve([]);
                     }
                 };
                 
                 request.onupgradeneeded = (event) => {
                     console.log('Base de donn√©es IndexedDB n√©cessite une mise √† jour');
                     const db = event.target.result;
                     db.close();
                     resolve([]);
                 };
             });
         }
        
        async function getCheckSessionsFromIndexedDB() {
            return new Promise((resolve) => {
                // Utiliser la version 2 pour correspondre √† la configuration
                const request = indexedDB.open('checkeasy_db', 2);

                request.onsuccess = () => {
                    const db = request.result;
                    console.log('üìÇ IndexedDB ouverte, version:', db.version);
                    console.log('üìã Stores disponibles:', Array.from(db.objectStoreNames));

                    // V√©rifier si le store existe
                    if (!db.objectStoreNames.contains('checkSessions')) {
                        console.warn('‚ö†Ô∏è Store checkSessions non trouv√© dans IndexedDB');
                        console.log('üí° Astuce: Cr√©ez une session dans l\'application pour initialiser la DB');
                        resolve({});
                        db.close();
                        return;
                    }

                    try {
                        const transaction = db.transaction(['checkSessions'], 'readonly');
                        const store = transaction.objectStore('checkSessions');
                        const getAllRequest = store.getAll();

                        getAllRequest.onsuccess = () => {
                            const sessions = getAllRequest.result;
                            console.log('‚úÖ CheckSessions charg√©es depuis IndexedDB:', sessions.length);

                            if (sessions.length > 0) {
                                console.log('üìä Premi√®re session:', sessions[0]);
                            }

                            // Convertir le tableau en objet avec checkId comme cl√©
                            const sessionsObj = {};
                            sessions.forEach(session => {
                                sessionsObj[session.checkId] = session;
                            });

                            db.close();
                            resolve(sessionsObj);
                        };

                        getAllRequest.onerror = () => {
                            console.error('‚ùå Erreur lecture checkSessions:', getAllRequest.error);
                            db.close();
                            resolve({});
                        };
                    } catch (error) {
                        console.error('‚ùå Erreur transaction:', error);
                        db.close();
                        resolve({});
                    }
                };

                request.onerror = () => {
                    console.error('‚ùå Erreur ouverture IndexedDB:', request.error);
                    resolve({});
                };

                request.onblocked = () => {
                    console.warn('‚ö†Ô∏è Ouverture IndexedDB bloqu√©e (connexions ouvertes)');
                    resolve({});
                };
            });
        }

        function getCheckSessions() {
            try {
                const sessionsData = localStorage.getItem('checkeasy_check_sessions');
                return sessionsData ? JSON.parse(sessionsData) : {};
            } catch (e) {
                console.warn('Erreur parsing check sessions:', e);
                return {};
            }
        }
        
        function getAppFlowState() {
            try {
                const flowData = localStorage.getItem('app-flow-state');
                return flowData ? JSON.parse(flowData) : null;
            } catch (e) {
                console.warn('Erreur parsing app flow state:', e);
                return null;
            }
        }
        
        function displayParcours(parcours, sessions, appFlowState) {
            const container = document.getElementById('parcoursContent');
            
            if (parcours.length === 0 && Object.keys(sessions).length === 0 && !appFlowState) {
                container.innerHTML = '<div class="alert info">Aucun parcours trouv√©</div>';
                return;
            }
            
            let html = '';
            
            // Afficher app-flow-state si disponible
            if (appFlowState) {
                html += `
                    <div class="parcours-card">
                        <div class="parcours-header">
                            <div class="parcours-title">üîÑ Session active</div>
                            <button class="btn btn-small" onclick="viewData('app-flow-state', ${JSON.stringify(appFlowState).replace(/"/g, '&quot;')})">üëÅÔ∏è Voir</button>
                        </div>
                        <div class="parcours-meta">
                            Type: ${appFlowState.flowType || 'inconnu'} | 
                            Pi√®ce: ${appFlowState.currentPieceId || 'N/A'}
                        </div>
                    </div>
                `;
            }
            
            // Afficher parcours IndexedDB
            parcours.forEach((p, index) => {
                const data = p.data || {};
                // üîß FIX: Utiliser 'piece' (singulier) au lieu de 'pieces' (pluriel)
                const pieces = data.piece || [];
                const metadata = p.metadata || {};
                const roomsCount = metadata.roomsCount || pieces.length;
                const progress = pieces.length > 0 ? Math.round((data.completedPieces || 0) / pieces.length * 100) : 0;

                html += `
                    <div class="parcours-card">
                        <div class="parcours-header">
                            <div class="parcours-title">üìã ${data.parcoursName || data.logementName || p.id}</div>
                            <button class="btn btn-small" onclick="viewParcours(${index})">üëÅÔ∏è D√©tails</button>
                        </div>
                        <div class="parcours-meta">
                            ID: ${p.id} | ${roomsCount} pi√®ces |
                            ${new Date(p.cachedAt || 0).toLocaleDateString()}
                        </div>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${progress}%"></div>
                        </div>
                        <small>Progression: ${progress}%</small>
                    </div>
                `;
            });
            
            // Afficher sessions de contr√¥le
            Object.entries(sessions).forEach(([checkId, sessionData]) => {
                html += `
                    <div class="parcours-card">
                        <div class="parcours-header">
                            <div class="parcours-title">üè† Session contr√¥le</div>
                            <button class="btn btn-small" onclick="viewData('session-${checkId}', ${JSON.stringify(sessionData).replace(/"/g, '&quot;')})">üëÅÔ∏è Voir</button>
                        </div>
                        <div class="parcours-meta">
                            CheckID: ${checkId} | 
                            Logement: ${sessionData.logement_id || 'N/A'}
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            
            // Stocker les donn√©es pour les d√©tails
            window.parcoursData = parcours;
        }
        
        function viewParcours(index) {
            const parcours = window.parcoursData[index];
            if (!parcours) return;
            
            const modal = createModal(
                `Parcours: ${parcours.id}`,
                `<div class="json-viewer">${JSON.stringify(parcours, null, 2)}</div>`
            );
            document.body.appendChild(modal);
        }
        
        function viewData(title, data) {
            const modal = createModal(
                title,
                `<div class="json-viewer">${JSON.stringify(data, null, 2)}</div>`
            );
            document.body.appendChild(modal);
        }
        
        // === LOCALSTORAGE ===
        function refreshLocalStorage() {
            const keys = Object.keys(localStorage);
            const container = document.getElementById('localStorageContent');
            
            if (keys.length === 0) {
                container.innerHTML = '<div class="alert info">Aucune donn√©e localStorage</div>';
                return;
            }
            
            displayLocalStorageKeys(keys);
        }
        
        function displayLocalStorageKeys(keys, filter = '') {
            const filteredKeys = keys.filter(key => 
                key.toLowerCase().includes(filter.toLowerCase())
            );
            
            const container = document.getElementById('localStorageContent');
            
            if (filteredKeys.length === 0) {
                container.innerHTML = '<div class="alert info">Aucune cl√© trouv√©e</div>';
                return;
            }
            
            let html = '<div class="key-value-grid">';
            
            filteredKeys.forEach(key => {
                const value = localStorage.getItem(key);
                let preview = value;
                
                try {
                    const parsed = JSON.parse(value);
                    preview = JSON.stringify(parsed, null, 2);
                } catch (e) {
                    // Garder la valeur originale
                }
                
                const truncated = preview.length > 200 ? preview.substring(0, 200) + '...' : preview;
                
                html += `
                    <div class="key-value">
                        <div class="key">${key}</div>
                        <div class="value">${truncated}</div>
                        <div class="actions">
                            <button class="btn btn-small" onclick="viewLocalStorageItem('${key}')">üëÅÔ∏è</button>
                            <button class="btn btn-small danger" onclick="deleteLocalStorageItem('${key}')">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            });
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function filterLocalStorage() {
            const filter = document.getElementById('localStorageSearch').value;
            const keys = Object.keys(localStorage);
            displayLocalStorageKeys(keys, filter);
        }
        
        function viewLocalStorageItem(key) {
            const value = localStorage.getItem(key);
            let displayValue = value;
            
            try {
                const parsed = JSON.parse(value);
                displayValue = JSON.stringify(parsed, null, 2);
            } catch (e) {
                // Garder valeur originale
            }
            
            const modal = createModal(
                `LocalStorage: ${key}`,
                `<div class="json-viewer">${displayValue}</div>`
            );
            document.body.appendChild(modal);
        }
        
        function deleteLocalStorageItem(key) {
            if (confirm(`Supprimer "${key}" ?`)) {
                localStorage.removeItem(key);
                showAlert('Cl√© supprim√©e', 'success');
                refreshLocalStorage();
            }
        }
        
        function clearLocalStorage() {
            if (confirm('‚ö†Ô∏è Supprimer TOUT localStorage ?')) {
                localStorage.clear();
                showAlert('LocalStorage vid√©', 'success');
                refreshLocalStorage();
            }
        }
        
        // === INDEXEDDB ===
        async function refreshIndexedDB() {
            try {
                const databases = await indexedDB.databases();
                const select = document.getElementById('dbSelect');
                
                select.innerHTML = '<option value="">S√©lectionner base</option>';
                
                databases.forEach(db => {
                    const option = document.createElement('option');
                    option.value = db.name;
                    option.textContent = `${db.name} (v${db.version})`;
                    select.appendChild(option);
                });
                
            } catch (error) {
                console.error('Erreur IndexedDB:', error);
            }
        }
        
        async function loadDatabase() {
            const dbName = document.getElementById('dbSelect').value;
            if (!dbName) return;
            
            const container = document.getElementById('indexedDBContent');
            container.innerHTML = '<div class="loading"></div> Chargement...';
            
            try {
                const request = indexedDB.open(dbName);
                
                request.onsuccess = function(event) {
                    const db = event.target.result;
                    const storeNames = Array.from(db.objectStoreNames);
                    
                    let html = `<div class="section"><h3>Stores dans ${dbName}:</h3>`;
                    html += '<div class="stats-grid">';
                    
                    storeNames.forEach(storeName => {
                        html += `
                            <div class="stat-card">
                                <button class="btn" onclick="loadStore('${dbName}', '${storeName}')">${storeName}</button>
                            </div>
                        `;
                    });
                    
                    html += '</div></div>';
                    container.innerHTML = html;
                    db.close();
                };
                
            } catch (error) {
                container.innerHTML = `<div class="alert error">Erreur: ${error.message}</div>`;
            }
        }
        
         async function loadStore(dbName, storeName) {
             const container = document.getElementById('indexedDBContent');
             container.innerHTML = '<div class="loading"></div> Chargement store...';
             
             try {
                 const request = indexedDB.open(dbName);
                 
                 request.onerror = function() {
                     container.innerHTML = '<div class="alert error">Erreur ouverture base de donn√©es</div>';
                 };
                 
                 request.onsuccess = function(event) {
                     const db = event.target.result;
                     
                     try {
                         // V√©rifier que le store existe
                         if (!db.objectStoreNames.contains(storeName)) {
                             container.innerHTML = `<div class="alert error">Store "${storeName}" non trouv√©</div>`;
                             db.close();
                             return;
                         }
                         
                         const transaction = db.transaction([storeName], 'readonly');
                         
                         transaction.onerror = function() {
                             container.innerHTML = `<div class="alert error">Erreur transaction sur "${storeName}"</div>`;
                             db.close();
                         };
                         
                         const store = transaction.objectStore(storeName);
                         const getAllRequest = store.getAll();
                         
                         getAllRequest.onsuccess = function() {
                             const data = getAllRequest.result;
                             
                             let html = `<div class="section"><h3>${storeName} (${data.length} enregistrements)</h3>`;
                             
                             if (data.length > 0) {
                                 html += '<div class="json-viewer">';
                                 html += JSON.stringify(data, null, 2);
                                 html += '</div>';
                             } else {
                                 html += '<div class="alert info">Store vide</div>';
                             }
                             
                             html += '</div>';
                             container.innerHTML = html;
                             db.close();
                         };
                         
                         getAllRequest.onerror = function() {
                             container.innerHTML = `<div class="alert error">Erreur lecture donn√©es du store "${storeName}"</div>`;
                             db.close();
                         };
                         
                     } catch (error) {
                         console.error('Erreur dans loadStore:', error);
                         container.innerHTML = `<div class="alert error">Erreur: ${error.message}</div>`;
                         db.close();
                     }
                 };
                 
             } catch (error) {
                 container.innerHTML = `<div class="alert error">Erreur: ${error.message}</div>`;
             }
         }
        
        // === PHOTOS ===
        function analyzePhotos() {
            const photoKeys = Object.keys(localStorage).filter(key => key.startsWith('uploaded_image_'));
            let totalSize = 0;
            let validPhotos = 0;
            
            const container = document.getElementById('photosContent');
            container.innerHTML = '<div class="loading"></div> Analyse des photos...';
            
            setTimeout(() => {
                let html = '';
                
                if (photoKeys.length === 0) {
                    html = '<div class="alert info">Aucune photo trouv√©e</div>';
                } else {
                    html = '<div class="data-table-container">';
                    html += '<table class="data-table">';
                    html += '<thead><tr><th>Cl√©</th><th>Taille</th><th>Type</th><th>Actions</th></tr></thead><tbody>';
                    
                    photoKeys.forEach(key => {
                        try {
                            const data = JSON.parse(localStorage.getItem(key) || '{}');
                            const size = localStorage.getItem(key).length;
                            totalSize += size;
                            validPhotos++;
                            
                            html += `
                                <tr>
                                    <td>${key.replace('uploaded_image_', '')}</td>
                                    <td>${Math.round(size / 1024)} KB</td>
                                    <td>${data.url ? 'üåê URL' : data.dataUrl ? 'üì± Local' : '‚ùì'}</td>
                                    <td>
                                        <button class="btn btn-small" onclick="viewPhoto('${key}')">üëÅÔ∏è</button>
                                        <button class="btn btn-small danger" onclick="deletePhoto('${key}')">üóëÔ∏è</button>
                                    </td>
                                </tr>
                            `;
                        } catch (e) {
                            html += `
                                <tr>
                                    <td>${key}</td>
                                    <td colspan="3" class="alert error">Erreur parsing</td>
                                </tr>
                            `;
                        }
                    });
                    
                    html += '</tbody></table></div>';
                }
                
                // Mettre √† jour les stats
                document.getElementById('totalPhotos').textContent = validPhotos;
                document.getElementById('totalPhotoSize').textContent = Math.round(totalSize / 1024 / 1024 * 100) / 100 + ' MB';
                
                container.innerHTML = html;
            }, 500);
        }
        
        function viewPhoto(key) {
            try {
                const data = JSON.parse(localStorage.getItem(key) || '{}');
                const modal = createModal(
                    `Photo: ${key}`,
                    `<div class="json-viewer">${JSON.stringify(data, null, 2)}</div>`
                );
                document.body.appendChild(modal);
            } catch (e) {
                showAlert('Erreur lecture photo', 'error');
            }
        }
        
        function deletePhoto(key) {
            if (confirm(`Supprimer la photo ${key} ?`)) {
                localStorage.removeItem(key);
                showAlert('Photo supprim√©e', 'success');
                analyzePhotos();
            }
        }
        
        // === HISTORIQUE WEBHOOKS ===
        function refreshWebhooksHistory() {
            const webhooks = getAllStoredWebhooks();
            
            // Mettre √† jour les statistiques
            const totalSent = webhooks.reduce((sum, w) => sum + w.sendCount, 0);
            const lastWebhook = webhooks[0];
            
            document.getElementById('totalWebhooks').textContent = totalSent;
            document.getElementById('uniqueWebhooks').textContent = webhooks.length;
            document.getElementById('lastWebhookDate').textContent = lastWebhook ? 
                new Date(lastWebhook.lastSent || lastWebhook.created).toLocaleDateString() : '-';
            
            // Afficher l'historique
            displayWebhooksHistory(webhooks);
        }
        
        function displayWebhooksHistory(webhooks) {
            const container = document.getElementById('webhooksHistoryContent');
            
            if (webhooks.length === 0) {
                container.innerHTML = '<div class="alert info">Aucun webhook envoy√© pour le moment</div>';
                return;
            }
            
            let html = '<div class="data-table-container">';
            html += '<table class="data-table">';
            html += `
                <thead>
                    <tr>
                        <th>ID Persistant</th>
                        <th>Logement</th>
                        <th>Utilisateur</th>
                        <th>Cr√©√©</th>
                        <th>Dernier envoi</th>
                        <th>Envois</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody>
            `;
            
            webhooks.forEach(webhook => {
                const shortId = webhook.id.length > 30 ? webhook.id.substring(0, 30) + '...' : webhook.id;
                const createdDate = new Date(webhook.created).toLocaleDateString();
                const lastSentDate = webhook.lastSent ? new Date(webhook.lastSent).toLocaleDateString() : 'Jamais';
                
                html += `
                    <tr>
                        <td title="${webhook.id}">
                            <code>${shortId}</code>
                        </td>
                        <td>${webhook.logement_id || '-'}</td>
                        <td>${webhook.user_id || '-'}</td>
                        <td>${createdDate}</td>
                        <td>${lastSentDate}</td>
                        <td>
                            <span class="badge ${webhook.sendCount > 0 ? 'success' : 'secondary'}">
                                ${webhook.sendCount}x ${webhook.type || 'webhook'}
                            </span>
                        </td>
                        <td>
                            <button class="btn btn-small" onclick="viewWebhookDetails('${webhook.id}')">üëÅÔ∏è</button>
                            <button class="btn btn-small" onclick="copyWebhookId('${webhook.id}')">üìã</button>
                            <button class="btn btn-small danger" onclick="deleteWebhookHistory('${webhook.id}')">üóëÔ∏è</button>
                        </td>
                    </tr>
                `;
            });
            
            html += '</tbody></table></div>';
            container.innerHTML = html;
        }
        
        function viewWebhookDetails(webhookId) {
            const webhookData = getStoredWebhookData(webhookId);
            if (!webhookData) {
                showAlert('Webhook non trouv√©', 'error');
                return;
            }
            
            const modal = createModal(
                `D√©tails Webhook: ${webhookId}`,
                `
                <div class="json-enhanced">${formatJsonWithColors(webhookData, 0)}</div>
                <div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                    <strong>üîç Informations pratiques:</strong><br>
                    ‚Ä¢ Cet ID est <strong>persistant</strong> - il sera r√©utilis√© pour les m√™mes donn√©es<br>
                    ‚Ä¢ Bas√© sur: logement, utilisateur et √©tats des pi√®ces<br>
                    ‚Ä¢ Cr√©√© le: ${new Date(webhookData.created).toLocaleString()}<br>
                    ‚Ä¢ Envoy√© ${webhookData.sendCount} fois
                </div>
                `
            );
            document.body.appendChild(modal);
        }
        
        function copyWebhookId(webhookId) {
            navigator.clipboard.writeText(webhookId).then(() => {
                showAlert('ID copi√© dans le presse-papier', 'success');
            }).catch(() => {
                // Fallback pour navigateurs anciens
                const textarea = document.createElement('textarea');
                textarea.value = webhookId;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                showAlert('ID copi√©', 'success');
            });
        }
        
        function deleteWebhookHistory(webhookId) {
            if (confirm(`Supprimer l'historique du webhook ${webhookId.substring(0, 20)}... ?`)) {
                localStorage.removeItem(`webhook_metadata_${webhookId}`);
                showAlert('Historique supprim√©', 'success');
                refreshWebhooksHistory();
            }
        }
        
        function clearWebhooksHistory() {
            if (confirm('‚ö†Ô∏è Supprimer TOUT l\'historique des webhooks ?')) {
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('webhook_metadata_')) {
                        localStorage.removeItem(key);
                    }
                });
                showAlert('Historique vid√©', 'success');
                refreshWebhooksHistory();
            }
        }
        
        // === PREVIEW STRUCTURE √âTAPES ===
        
        function previewStructureEtapes() {
            if (!selectedCheckId || !checkIdData[selectedCheckId]) {
                showAlert('S√©lectionnez un CheckID d\'abord', 'error');
                return;
            }
            
            const sessionData = checkIdData[selectedCheckId];
            
            try {
                console.log('üèóÔ∏è Preview de la structure par √©tapes...');
                
                // Extraire la structure pour CheckIn et CheckOut
                const etapesCheckin = extractEtapesStructurees(sessionData, 'checkin');
                const etapesCheckout = extractEtapesStructurees(sessionData, 'checkout');
                
                const preview = {
                    session_id: selectedCheckId,
                    timestamp: new Date().toISOString(),
                    
                    checkin_structure: {
                        total_pieces: etapesCheckin.length,
                        pieces: etapesCheckin.map(piece => ({
                            piece_id: piece.piece_id,
                            piece_name: piece.piece_name,
                            total_etapes: piece.etapes.length,
                            etapes_overview: piece.etapes.map(etape => ({
                                etape_id: etape.etape_id,
                                type: etape.type,
                                status: etape.status,
                                has_interactions: etape.interactions.total_interactions > 0
                            })),
                            completion: `${piece.statistiques.etapes_completees}/${piece.statistiques.total_etapes}`,
                            completion_percentage: piece.statistiques.completion_percentage
                        }))
                    },
                    
                    checkout_structure: {
                        total_pieces: etapesCheckout.length,
                        pieces: etapesCheckout.map(piece => ({
                            piece_id: piece.piece_id,
                            piece_name: piece.piece_name,
                            total_etapes: piece.etapes.length,
                            etapes_overview: piece.etapes.map(etape => ({
                                etape_id: etape.etape_id,
                                type: etape.type,
                                status: etape.status,
                                has_interactions: etape.interactions.total_interactions > 0
                            })),
                            completion: `${piece.statistiques.etapes_completees}/${piece.statistiques.total_etapes}`,
                            completion_percentage: piece.statistiques.completion_percentage
                        }))
                    },
                    
                    statistiques_globales: {
                        checkin: {
                            pieces: etapesCheckin.length,
                            etapes: etapesCheckin.reduce((acc, piece) => acc + piece.etapes.length, 0),
                            completees: etapesCheckin.reduce((acc, piece) => 
                                acc + piece.etapes.filter(e => e.status === 'completed').length, 0)
                        },
                        checkout: {
                            pieces: etapesCheckout.length,
                            etapes: etapesCheckout.reduce((acc, piece) => acc + piece.etapes.length, 0),
                            completees: etapesCheckout.reduce((acc, piece) => 
                                acc + piece.etapes.filter(e => e.status === 'completed').length, 0)
                        }
                    }
                };
                
                // Affichage dans modal
                const modal = createModal('üèóÔ∏è Preview Structure √âtapes', `
                    <div style="font-family: monospace; font-size: 12px;">
                        <div style="margin: 15px 0; padding: 10px; background: #e6f3ff; border-radius: 3px;">
                            <h4>üìä Vue d'ensemble</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div>
                                    <strong>üì• CheckIn:</strong><br>
                                    ‚Ä¢ ${preview.statistiques_globales.checkin.pieces} pi√®ces<br>
                                    ‚Ä¢ ${preview.statistiques_globales.checkin.etapes} √©tapes<br>
                                    ‚Ä¢ ${preview.statistiques_globales.checkin.completees} compl√©t√©es
                                </div>
                                <div>
                                    <strong>üì§ CheckOut:</strong><br>
                                    ‚Ä¢ ${preview.statistiques_globales.checkout.pieces} pi√®ces<br>
                                    ‚Ä¢ ${preview.statistiques_globales.checkout.etapes} √©tapes<br>
                                    ‚Ä¢ ${preview.statistiques_globales.checkout.completees} compl√©t√©es
                                </div>
                            </div>
                        </div>
                        
                        <div style="margin: 15px 0;">
                            <h4>üè† D√©tail par pi√®ce (CheckIn):</h4>
                            ${preview.checkin_structure.pieces.map(piece => `
                                <div style="background: #f8f9fa; padding: 8px; border-radius: 3px; margin: 5px 0;">
                                    <strong>${piece.piece_name}</strong> (${piece.completion}) - ${piece.completion_percentage}%<br>
                                    <div style="font-size: 10px; color: #666;">
                                        ${piece.etapes_overview.map(etape => 
                                            `${etape.etape_id.substring(0,8)}... [${etape.type}] ${etape.status === 'completed' ? '‚úÖ' : '‚è≥'}`
                                        ).join(' | ')}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <details>
                            <summary>üìÑ Donn√©es compl√®tes</summary>
                            <pre style="font-size: 10px; background: #f8f9fa; padding: 10px; border-radius: 3px; overflow: auto; max-height: 300px;">${JSON.stringify(preview, null, 2)}</pre>
                        </details>
                    </div>
                `);
                modal.show();
                
            } catch (error) {
                console.error('‚ùå Erreur preview structure:', error);
                showAlert(`‚ùå Erreur: ${error.message}`, 'error');
            }
        }
        
        // === V√âRIFICATION SOURCE DONN√âES ===
        
        function verifyEtapeSourceData() {
            console.log('üî¨ V√âRIFICATION COMPL√àTE DE LA SOURCE DES √âTAPES');
            
            try {
                // 1. R√©cup√©rer les donn√©es de session
                const sessionData = JSON.parse(localStorage.getItem('checkSessionData') || '{}');
                const activeCheckId = localStorage.getItem('activeCheckId') || 'defaultCheckId';
                const checkSession = sessionData[activeCheckId];
                
                if (!checkSession) {
                    throw new Error('Aucune session trouv√©e');
                }
                
                console.log('üìã SESSION TROUV√âE:', activeCheckId);
                
                // 2. V√©rifier la source des donn√©es parcoursData
                const sourceVerification = verifyParcoursDataSource(checkSession);
                
                // 3. Comparer avec vos donn√©es d'exemple
                const yourExampleData = {
                    pieceID: "1753358727481x453383598298510400",
                    expectedEtapeIDs: [
                        "1753358727684x171131427093090140",
                        "1753358727693x379060051192319400",
                        "1759155543901x672381304534728700"
                    ]
                };
                
                // 4. V√©rifier si on trouve cette pi√®ce dans parcoursData
                let foundPiece = null;
                let matchingEtapes = [];
                
                if (checkSession.parcoursData?.piece) {
                    foundPiece = checkSession.parcoursData.piece.find(p => p.pieceID === yourExampleData.pieceID);
                    if (foundPiece) {
                        matchingEtapes = foundPiece.etapes?.map(e => e.etapeID) || [];
                    }
                }
                
                // 5. Analyser les donn√©es buttonClicks stock√©es
                let storedEtapeIds = [];
                if (checkSession.progress?.interactions?.buttonClicks) {
                    Object.values(checkSession.progress.interactions.buttonClicks).flat().forEach(click => {
                        if (click.pieceId === yourExampleData.pieceID) {
                            storedEtapeIds.push(click.etapeId);
                        }
                    });
                }
                
                // 6. Cr√©er le rapport complet
                const report = {
                    source_verification: sourceVerification,
                    your_example: yourExampleData,
                    found_in_parcours_data: {
                        piece_found: !!foundPiece,
                        piece_name: foundPiece?.nom || 'N/A',
                        etapes_found: matchingEtapes,
                        matches_expected: matchingEtapes.some(id => yourExampleData.expectedEtapeIDs.includes(id))
                    },
                    stored_interactions: {
                        stored_etape_ids: [...new Set(storedEtapeIds)],
                        uses_piece_id_as_etape_id: storedEtapeIds.includes(yourExampleData.pieceID),
                        total_clicks: storedEtapeIds.length
                    }
                };
                
                console.log('üìä RAPPORT COMPLET:');
                console.table(report.found_in_parcours_data);
                console.table(report.stored_interactions);
                
                // 7. Conclusion
                let conclusion = '';
                if (foundPiece && matchingEtapes.length > 0) {
                    if (report.found_in_parcours_data.matches_expected) {
                        conclusion = '‚úÖ DONN√âES VALIDES: Les etapeID dans parcoursData correspondent √† vos exemples';
                    } else {
                        conclusion = '‚ö†Ô∏è DONN√âES DIFF√âRENTES: parcoursData contient des etapeID diff√©rents de vos exemples';
                    }
                } else {
                    conclusion = '‚ùå DONN√âES MANQUANTES: La pi√®ce de votre exemple n\'est pas trouv√©e dans parcoursData';
                }
                
                if (report.stored_interactions.uses_piece_id_as_etape_id) {
                    conclusion += '\nüö® PROBL√àME CONFIRM√â: Les interactions stockent pieceID au lieu d\'etapeID';
                }
                
                console.log('üéØ CONCLUSION:', conclusion);
                
                // 8. Afficher dans une modal
                const modal = createModal('üî¨ V√©rification Source √âtapes', `
                    <div style="font-family: monospace; font-size: 12px;">
                        <h4>üì° Source des donn√©es:</h4>
                        <p><strong>Type:</strong> ${sourceVerification.source}</p>
                        <p><strong>Valide:</strong> ${sourceVerification.isValid ? '‚úÖ' : '‚ùå'}</p>
                        
                        <h4>üéØ Test avec votre exemple:</h4>
                        <p><strong>Pi√®ce recherch√©e:</strong> ${yourExampleData.pieceID}</p>
                        <p><strong>Trouv√©e dans parcoursData:</strong> ${foundPiece ? '‚úÖ ' + foundPiece.nom : '‚ùå'}</p>
                        
                        <h4>üìã EtapeIDs attendus vs trouv√©s:</h4>
                        <div style="background: #f0f0f0; padding: 10px; margin: 10px 0;">
                            <strong>Attendus:</strong><br>
                            ${yourExampleData.expectedEtapeIDs.map(id => `‚Ä¢ ${id}`).join('<br>')}
                        </div>
                        <div style="background: #f0f0f0; padding: 10px; margin: 10px 0;">
                            <strong>Trouv√©s dans parcoursData:</strong><br>
                            ${matchingEtapes.length > 0 ? matchingEtapes.map(id => `‚Ä¢ ${id}`).join('<br>') : 'Aucun'}
                        </div>
                        
                        <h4>üîç EtapeIDs stock√©s dans les interactions:</h4>
                        <div style="background: #fff3cd; padding: 10px; margin: 10px 0;">
                            ${storedEtapeIds.length > 0 ? storedEtapeIds.map(id => `‚Ä¢ ${id}`).join('<br>') : 'Aucune interaction trouv√©e'}
                        </div>
                        
                        <div style="margin-top: 20px; padding: 15px; background: ${foundPiece && matchingEtapes.length > 0 ? '#d4edda' : '#f8d7da'}; border-radius: 5px;">
                            <strong>CONCLUSION:</strong><br>
                            ${conclusion.replace(/\n/g, '<br>')}
                        </div>
                    </div>
                `);
                
                return report;
                
            } catch (error) {
                console.error('‚ùå Erreur lors de la v√©rification:', error);
                showAlert('Erreur lors de la v√©rification: ' + error.message, 'error');
            }
        }
        
        // === CHARGEMENT DONN√âES API ===
        
        async function loadParcoursDataFromApi() {
            console.log('üì° Chargement des donn√©es parcours depuis l\'API...');
            
            try {
                // R√©cup√©rer le parcours ID depuis la session
                const sessionData = JSON.parse(localStorage.getItem('checkSessionData') || '{}');
                const activeCheckId = localStorage.getItem('activeCheckId') || 'defaultCheckId';
                const checkSession = sessionData[activeCheckId];
                
                let parcoursId = null;
                
                // Essayer de r√©cup√©rer le parcours ID
                if (checkSession?.parcoursInfo?.parcours_id) {
                    parcoursId = checkSession.parcoursInfo.parcours_id;
                } else if (checkSession?.parcoursData?.parcourID) {
                    parcoursId = checkSession.parcoursData.parcourID;
                } else {
                    // Utiliser l'ID par d√©faut pour le test
                    parcoursId = '1758613142823x462099088965380700';
                    console.log('‚ö†Ô∏è Utilisation de l\'ID de test par d√©faut:', parcoursId);
                }
                
                showAlert(`üîÑ Chargement du parcours ${parcoursId.substring(0, 13)}...`, 'info');
                
                // Appel √† l'API
                const response = await fetch(`https://checkeasy-57905.bubbleapps.io/version-test/api/1.1/wf/endpointPiece?parcours=${parcoursId}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const parcoursData = await response.json();
                console.log('‚úÖ Donn√©es API r√©cup√©r√©es:', parcoursData);
                
                // Sauvegarder dans la session
                if (!checkSession.parcoursData) {
                    checkSession.parcoursData = {};
                }
                
                checkSession.parcoursData = parcoursData;
                sessionData[activeCheckId] = checkSession;
                localStorage.setItem('checkSessionData', JSON.stringify(sessionData));
                
                showAlert(`‚úÖ Donn√©es parcours charg√©es! ${parcoursData.piece?.length || 0} pi√®ces trouv√©es`, 'success');
                
                // Analyser automatiquement
                setTimeout(() => {
                    console.log('üìä Structure charg√©e:', {
                        totalPieces: parcoursData.piece?.length || 0,
                        totalEtapes: parcoursData.piece?.reduce((acc, p) => acc + (p.etapes?.length || 0), 0) || 0
                    });
                }, 1000);
                
            } catch (error) {
                console.error('‚ùå Erreur lors du chargement:', error);
                showAlert(`‚ùå Erreur: ${error.message}`, 'error');
            }
        }
        
        // === TEST MAPPING ETAPE ID ===
        
        async function testEtapeIdMapping() {
            console.log('üó∫Ô∏è Test du mapping etapeId...');
            
            try {
                // Simuler quelques cas de test typiques
                const testCases = [
                    { taskId: '1758613144699x173912139510638200', pieceId: '1758613142342x317402074465620540', desc: 'taskId = etapeId direct' },
                    { taskId: 'chambre_0', pieceId: '1758613142342x317402074465620540', desc: 'taskId = pieceName + index' },
                    { taskId: 'chambre_photo_1', pieceId: '1758613142342x317402074465620540', desc: 'taskId = pieceName + photo + index' },
                    { taskId: 'salon_todo_0', pieceId: '1758613142342x835298812245656200', desc: 'taskId = pieceName + todo + index' },
                    { taskId: 'invalid_task', pieceId: '1758613142342x317402074465620540', desc: 'taskId invalide (fallback)' },
                    { taskId: '', pieceId: '1758613142342x317402074465620540', desc: 'taskId vide (premi√®re √©tape pi√®ce)' }
                ];
                
                let results = [];
                
                for (const testCase of testCases) {
                    // Simuler l'appel au mapper (nous n'avons pas acc√®s direct dans ce contexte)
                    console.log('üß™ Test mapping:', testCase);
                    
                    // Ici, nous pourrions faire une simulation bas√©e sur les donn√©es charg√©es
                    const sessionData = JSON.parse(localStorage.getItem('checkSessionData') || '{}');
                    const activeCheckId = localStorage.getItem('activeCheckId') || 'defaultCheckId';
                    const parcoursData = sessionData[activeCheckId]?.parcoursData;
                    
                    let mappedEtapeId = 'NON_TROUVE';
                    let method = 'fallback';
                    
                    if (parcoursData?.piece) {
                        // Chercher la pi√®ce
                        const piece = parcoursData.piece.find(p => p.pieceID === testCase.pieceId);
                        if (piece?.etapes) {
                            // Test 1: taskId direct = etapeID
                            const directMatch = piece.etapes.find(e => e.etapeID === testCase.taskId);
                            if (directMatch) {
                                mappedEtapeId = cleanEtapeId(directMatch.etapeID);
                                method = 'direct_match';
                            } else if (testCase.taskId.includes(piece.nom)) {
                                // Test 2: pattern bas√© sur le nom de pi√®ce
                                const indexMatch = testCase.taskId.match(/(\d+)$/);
                                if (indexMatch && piece.etapes[parseInt(indexMatch[1])]) {
                                    mappedEtapeId = cleanEtapeId(piece.etapes[parseInt(indexMatch[1])].etapeID);
                                    method = 'pattern_match';
                                }
                            }
                            
                            // Fallback: premi√®re √©tape de la pi√®ce
                            if (mappedEtapeId === 'NON_TROUVE' && piece.etapes.length > 0) {
                                mappedEtapeId = cleanEtapeId(piece.etapes[0].etapeID);
                                method = 'first_etape_fallback';
                            }
                        }
                    }
                    
                    results.push({
                        ...testCase,
                        mappedEtapeId,
                        method,
                        success: mappedEtapeId !== 'NON_TROUVE'
                    });
                }
                
                // Affichage des r√©sultats
                const modal = createModal('üó∫Ô∏è Test Mapping EtapeId', `
                    <div style="font-family: monospace; font-size: 12px;">
                        <div style="margin: 15px 0; padding: 10px; background: #f8f9fa; border-radius: 3px;">
                            <h4>üìä R√©sultats du mapping:</h4>
                            <p><strong>R√©ussis:</strong> ${results.filter(r => r.success).length}/${results.length}</p>
                        </div>
                        
                        <div style="margin: 15px 0;">
                            ${results.map(result => `
                                <div style="background: #f8f9fa; padding: 8px; border-radius: 3px; margin: 5px 0; border-left: 3px solid ${result.success ? '#28a745' : '#dc3545'};">
                                    <strong>${result.desc}</strong><br>
                                    <span style="color: #666;">TaskId:</span> <code>"${result.taskId}"</code><br>
                                    <span style="color: #666;">PieceId:</span> <code>${result.pieceId.substring(0, 13)}...</code><br>
                                    <span style="color: #666;">Mapped EtapeId:</span> <code style="color: ${result.success ? '#28a745' : '#dc3545'};">${result.mappedEtapeId}</code><br>
                                    <span style="color: #666;">M√©thode:</span> <span style="color: #007bff;">${result.method}</span>
                                </div>
                            `).join('')}
                        </div>
                        
                        <details>
                            <summary>Donn√©es compl√®tes</summary>
                            <pre style="font-size: 10px; background: #f8f9fa; padding: 10px; border-radius: 3px; overflow: auto; max-height: 300px;">${JSON.stringify(results, null, 2)}</pre>
                        </details>
                    </div>
                `);
                modal.show();
                
            } catch (error) {
                console.error('‚ùå Erreur test mapping:', error);
                showAlert(`‚ùå Erreur: ${error.message}`, 'error');
            }
        }
        
        // === OUTILS ===
        function cleanupData() {
            if (confirm('Nettoyer les donn√©es obsol√®tes ?')) {
                let cleaned = 0;
                
                // Nettoyer photos sans URL
                Object.keys(localStorage).filter(key => key.startsWith('uploaded_image_')).forEach(key => {
                    try {
                        const data = JSON.parse(localStorage.getItem(key) || '{}');
                        if (!data.url && !data.dataUrl) {
                            localStorage.removeItem(key);
                            cleaned++;
                        }
                    } catch (e) {
                        localStorage.removeItem(key);
                        cleaned++;
                    }
                });
                
                showAlert(`${cleaned} √©l√©ments nettoy√©s`, 'success');
                refreshParcours();
            }
        }
        
        function resetAll() {
            if (confirm('‚ö†Ô∏è DANGER: Tout supprimer ?')) {
                if (confirm('√ätes-vous S√õR ?')) {
                    localStorage.clear();
                    
                    // Supprimer IndexedDB
                    indexedDB.databases().then(dbs => {
                        dbs.forEach(db => indexedDB.deleteDatabase(db.name));
                    });
                    
                    showAlert('Reset effectu√©!', 'success');
                    setTimeout(() => location.reload(), 2000);
                }
            }
        }
        
        function runFullDiagnostic() {
            const container = document.getElementById('diagnosticContent');
            container.innerHTML = '<div class="loading"></div> Diagnostic...';
            
            setTimeout(() => {
                const diagnostic = {
                    localStorage: {
                        keys: Object.keys(localStorage).length,
                        photos: Object.keys(localStorage).filter(k => k.startsWith('uploaded_image_')).length,
                        sessions: Object.keys(localStorage).filter(k => k.includes('session')).length,
                        totalSize: JSON.stringify(localStorage).length
                    },
                    browser: {
                        userAgent: navigator.userAgent,
                        language: navigator.language,
                        online: navigator.onLine
                    },
                    storage: {
                        localStorageSupported: typeof(Storage) !== "undefined",
                        indexedDBSupported: 'indexedDB' in window
                    }
                };
                
                container.innerHTML = '<div class="json-viewer">' + JSON.stringify(diagnostic, null, 2) + '</div>';
            }, 1000);
        }
        
        // === UTILITAIRES ===
        function showAlert(message, type) {
            const alert = document.createElement('div');
            alert.className = `alert ${type}`;
            alert.textContent = message;
            alert.style.position = 'fixed';
            alert.style.top = '20px';
            alert.style.right = '20px';
            alert.style.zIndex = '9999';
            
            document.body.appendChild(alert);
            
            setTimeout(() => alert.remove(), 3000);
        }
        
        function createModal(title, content) {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.5); display: flex; align-items: center;
                justify-content: center; z-index: 10000;
            `;
            
            const modalContent = document.createElement('div');
            modalContent.style.cssText = `
                background: white; padding: 20px; border-radius: 10px;
                max-width: 90%; max-height: 90%; overflow: auto;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            `;
            
            modalContent.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3>${title}</h3>
                    <button onclick="this.closest('[style*=\"fixed\"]').remove()" 
                            style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 5px; cursor: pointer;">‚úï</button>
                </div>
                ${content}
            `;
            
            modal.appendChild(modalContent);
            modal.onclick = e => { if (e.target === modal) modal.remove(); };
            
            return modal;
        }
        
        // === INITIALISATION ===
        document.addEventListener('DOMContentLoaded', function() {
            console.log('=== üõ†Ô∏è INITIALISATION DATABASE BROWSER ===');
            console.log('üìç DOM charg√©');
            console.log('üìç Fonctions disponibles:', {
                sendWebhook: typeof sendWebhook,
                generateCheckinData: typeof generateCheckinData,
                generateCheckoutData: typeof generateCheckoutData,
                refreshCheckIds: typeof refreshCheckIds
            });
            
            // Initialiser la configuration des endpoints
            detectEnvironmentFromUrl();
            updateEndpointConfig();
            
            // Ajouter des listeners de debug sur les boutons
            const checkinBtn = document.getElementById('sendCheckinBtn');
            const checkoutBtn = document.getElementById('sendCheckoutBtn');
            
            if (checkinBtn) {
                console.log('‚úÖ Bouton CheckIn trouv√©');
                checkinBtn.addEventListener('click', function(e) {
                    console.log('üñ±Ô∏è CLIC sur bouton CheckIn d√©tect√©!', e);
                });
            } else {
                console.error('‚ùå Bouton CheckIn non trouv√©!');
            }
            
            if (checkoutBtn) {
                console.log('‚úÖ Bouton CheckOut trouv√©');
                checkoutBtn.addEventListener('click', function(e) {
                    console.log('üñ±Ô∏è CLIC sur bouton CheckOut d√©tect√©!', e);
                });
            } else {
                console.error('‚ùå Bouton CheckOut non trouv√©!');
            }
            
            refreshCheckIds();
            console.log('=== üõ†Ô∏è FIN INITIALISATION ===');
        });
    </script>
</body>
</html>
